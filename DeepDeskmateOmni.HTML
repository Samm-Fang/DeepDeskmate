<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepDeskmate</title>
    <style>
        body {
    font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background-color: #f4f7f6;
    color: #333;
    margin: 0;
    padding: 0; /* Remove body padding, handle spacing with wrapper */
    line-height: 1.6;
    display: flex;
    flex-direction: column; /* Ensure .app-wrapper and #footer stack vertically */
    min-height: 100vh;
    box-sizing: border-box;
}

.app-wrapper { /* New wrapper for main content and sidebar */
    display: flex;
    width: 100%;
    height: 100vh; /* Full viewport height */
    box-sizing: border-box;
    position: relative; /* For potential absolute positioning of sidebar if needed, or just for structure */
    overflow-x: hidden; /* Prevent horizontal scrollbar during transition */
}

/* Container for main content and floating buttons */
.container-wrapper {
    flex-grow: 1;
    position: relative; /* Crucial for positioning buttons relative to this wrapper */
    display: flex; /* To make .container take up available space */
    flex-direction: column; /* Stack .container and potentially other elements */
}

/* 侧边栏触发按钮样式 - 现在相对于 .container-wrapper 定位 */
.sidebar-toggle-button {
    position: absolute; /* Changed from fixed to absolute */
    bottom: 20px;
    right: 20px; /* Will be relative to .container-wrapper */
    width: 50px;
    height: 50px;
    background-color: #3d5aff;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    z-index: 1001; /* Ensure buttons are above content but below sidebar */
    transition: background-color 0.3s ease, bottom 0.3s ease, right 0.3s ease; /* Added right transition */
}

.sidebar-toggle-button:hover {
    background-color: #3451d2;
}

/* 设置按钮位置 (ID specific for clarity) */
#sidebar-toggle-button {
    /* right: 20px; bottom: 20px; are defaults from .sidebar-toggle-button */
}

/* Agent按钮位置 - 在设置按钮上方 (ID specific for clarity) */
#open-agent-button {
    bottom: 80px; /* 20px (settings button bottom) + 50px (settings button height) + 10px (gap) */
    /* right: 20px; is default from .sidebar-toggle-button */
    background-color: #5f84ff; /* 不同的颜色区分 */
}

#open-agent-button:hover {
    background-color: #3653d3;
}


.container { /* Main content area */
    flex-grow: 1;
    background-color: #ffffff;
    padding: 30px; /* Original padding */
    padding-bottom: 200px; /* Increased padding-bottom for background image space, adjust 200px as needed */
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 30px;
    overflow-y: auto; /* Allow scrolling for main content if it overflows */
    height: 100%; /* Fill height of app-wrapper */
    transition: margin-right 0.3s ease-in-out, width 0.3s ease-in-out; /* 修改过渡属性 */
    width: 100%; /* 初始宽度 */
    /* margin-right will be controlled by JS directly on style for width adjustment */
    background-image: url('images/background.png');
    background-repeat: no-repeat;
    background-position: center bottom;
    background-size: contain; /* Or adjust as needed, e.g., auto 150px */
}
/* .app-wrapper.sidebar-visible .container is no longer needed in this form */
/* .container.sidebar-open-content-shift class will be used by JS to adjust mainContainer style.width */

.main-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px; /* Gap between title and settings button */
}

h1 {
    color: #2c3e50;
    text-align: left; /* Align to left as it's part of a flex row now */
    margin-bottom: 0; /* Margin handled by main-header gap or container gap */
    font-size: 2.3rem;
    font-weight: 700;
}

#main-logo {
    max-height: 130px; /* 您可以根据需要调整这个值 */
    margin-top: -3px; /* 适当的顶部间距 */
    margin-left: 20px; /* 适当的左侧间距 */
    margin-bottom: -30px;
    width: auto;
    display: block; /* 如果需要，可以帮助对齐 */
}

/* 通用 Section 样式 */
.settings-section,
.input-section,
.output-section,
.table-generator-section {
    background-color: #fdfdfd;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.07);
    border: 1px solid #e9e9e9;
    display: flex;
    flex-direction: column;
    gap: 15px; /* Consistent gap within sections */
    border-left: 4px solid #4170ffcc; /* 新增蓝色左描边 */
}

h2 {
    color: #34495e;
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.7rem;
    border-bottom: 2px solid #417ceb;
    padding-bottom: 8px;
}

label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #5f626b;
    font-size: 1rem;
}

input[type="password"],
textarea,
input[type="text"],
input[type="number"],
select {
    width: 100%; /* Make inputs full width by default */
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 1rem;
    box-sizing: border-box;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

input:focus,
textarea:focus,
select:focus {
    border-color: #417ceb;
    box-shadow: 0 0 8px rgba(65, 124, 235, 0.25);
    outline: none;
}

textarea {
    resize: vertical;
    min-height: 90px;
}

button {
    background-color: #417ceb;
    color: #ffffff;
    border: none;
    padding: 10px 18px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.3s ease, opacity 0.3s ease;
    font-weight: 500;
    line-height: 1.5; /* Ensure text is vertically centered */
}

button:hover {
    background-color: #3562d4;
}

button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
    opacity: 0.7;
}

/* Specific Button Groupings and Alignments */
.settings-section {
    padding: 0; 
    border: none;
    box-shadow: none;
    background-color: transparent;
}
#open-settings-button {
    width: auto; 
}

.input-section {
    gap: 8px; 
}
.description-input-group {
    display: flex;
    align-items: flex-start; 
    gap: 10px;
}
.description-input-group textarea {
    flex-grow: 1; 
    margin-bottom: 0; 
}
.description-input-group #send-description {
    width: auto; 
    flex-shrink: 0; 
}


.section-header-controls {
    display: flex;
    justify-content: space-between; /* Pushes title and button to opposite ends */
    align-items: center; /* Vertically aligns items */
    margin-bottom: 10px; /* 与下方内容的间距 */
}

.section-header-controls h3 {
    margin: 0 10px 0 0; /* Removes default h3 bottom margin, adds right margin */
    font-size: 1.1em; /* Optional: adjust title size if needed */
}

.section-header-controls .inline-button {
    padding: 5px 10px; /* Smaller padding for inline buttons */
    font-size: 0.9em; /* Smaller font size for inline buttons */
    /* Add any other specific styling for these buttons */
}

.section-header-controls h2 {
    margin-bottom: 0; /* 移除h2的默认下边距，因为flex会处理对齐 */
}

.toggle-list-button {
    padding: 5px 10px; /* 调整内边距使按钮更小巧 */
    font-size: 1.2rem; 
    min-width: auto; 
    line-height: 1; 
    padding: 5px 8px; /* Adjusted padding for a smaller icon button */
    background-color: transparent; /* Make it less obtrusive */
    color: #5f626b;
    border: 1px solid #ccc;
}
.toggle-list-button:hover {
    background-color: #e9e9e9;
    color: #333;
}

/* Hide description input when personnel section is collapsed */
.output-section.personnel-collapsed .description-input-group {
    display: none;
}


.personnel-details-area {
    /* 这个区域将包含输入、按钮、加载提示和表格 */
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
}

.personnel-input-area {
    padding: 0; /* 移除内边距，因为它现在是更大区域的一部分 */
    border: none; /* 移除边框 */
    box-shadow: none; /* 移除阴影 */
    background-color: transparent; /* 透明背景 */
    flex-shrink: 0; /* 输入区域不可压缩 */
}

.personnel-controls { /* This is for .output-section .controls */
    display: flex;
    gap: 10px;
    margin-top: 10px; 
    margin-bottom: 10px; 
    flex-shrink: 0; 
}

.personnel-controls button { /* Buttons inside .output-section .controls */
    flex: 1 1 0; /* Allow buttons to grow and shrink equally, basis 0 */
}

/* New style for subheaders with buttons */
.section-subheader-with-button {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px; /* Adjust as needed */
}
.section-subheader-with-button h3 {
    margin-bottom: 0; /* Remove bottom margin from h3 inside this container */
    font-size: 1.2rem; /* Consistent with other similar h3s */
    color: #34495e;
}
/* .inline-button class is already styled and should work here */

.loading-indicator#loading-personnel {
    text-align: center;
    padding: 10px;
    background-color: #e9ecef;
    border-radius: 4px;
    margin-bottom: 10px;
    flex-shrink: 0; /* 加载指示器不可压缩 */
}

.import-personnel-section {
    margin-top: 10px !important; /* 减少与上方表格的距离 */
    padding-top: 10px !important;
    flex-shrink: 0; /* 导入区域不可压缩 */
}

.import-personnel-section {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.import-personnel-section button#import-personnel-button {
    align-self: flex-end; 
    width: auto;
}

.import-seat-table-section { 
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 20px; 
    padding-top: 20px; 
    border-top: 1px solid #eee;
    flex-shrink: 0; /* 导入座位表区域不可压缩 */
}
.import-seat-table-section h3 {
    margin-top: 0;
    margin-bottom: 5px; 
    font-size: 1.2rem; 
    color: #34495e;
}
.import-seat-table-section textarea {
    min-height: 80px; 
}
.import-seat-table-section button {
    align-self: flex-end;
    width: auto;
}

.seat-modification-section {
    display: flex;
    flex-direction: column;
    gap: 10px;
    flex-shrink: 0; /* 座位修改区域不可压缩 */
}
.seat-modification-section h3 {
    margin-top: 0;
    margin-bottom: 5px;
    font-size: 1.2rem;
    color: #34495e;
}
.seat-modification-section p {
    font-size: 0.9rem;
    color: #5f626b;
    margin-top: 0;
    margin-bottom: 5px;
}
.seat-modification-section textarea {
    min-height: 60px; 
}
.seat-modification-section button {
    align-self: flex-end;
    width: auto;
}
#seat-modification-output {
    font-size: 0.9rem;
    white-space: pre-wrap; 
    padding: 15px; /* Added padding to match thinking output */
    background-color: transparent; /* Added background to match thinking output */
    border: 2px dashed #cccccc; /* Changed border to match thinking output */
    border-radius: 8px; /* Added border-radius to match thinking output */
    margin-top: 10px; /* Added margin-top to match thinking output */
    flex-shrink: 0; /* 座位修改输出区域不可压缩 */
    /* display: none; /* Initial state if needed, then controlled by JS */
    /* opacity: 0; /* Initial state if needed, then controlled by JS */
    /* transition: opacity 0.3s ease-in-out; /* Transition if needed */
}


.table-generator-section .generator-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    align-items: center;
    flex-shrink: 0; /* 控制区域不可压缩 */
}
.table-generator-section .generator-controls label {
    margin-bottom: 0; 
}
.table-generator-section .generator-controls input[type="number"] {
    width: 70px; 
    margin-bottom: 0; 
}
.table-generator-section .generator-buttons {
    display: flex;
    gap: 10px;
    width: 100%;
    flex-shrink: 0; /* 按钮区域不可压缩 */
}
.table-generator-section .generator-buttons button {
    flex-grow: 1; 
}


.table-generator-section .arrangement-section {
    display: flex;
    flex-direction: row; 
    gap: 20px; 
    align-items: flex-start; /* 改回 flex-start，允许内容决定自身高度，避免被拉伸 */
    flex-shrink: 0; /* 编排区域不可压缩 */
}

.arrangement-remarks-wrapper, 
#seat-modification-section {
    flex: 1; 
    display: flex;
    flex-direction: column;
    gap: 10px; 
    padding: 15px; 
    border: 1px solid #e0e0e0; 
    border-radius: 8px; 
    background-color: #f9f9f9; 
    min-width: 0;
    /* 移除 align-items: stretch; 如果之前有的话，或确保其不影响内部对齐 */
}

/* 确保这些包装器内的标签和文本区域行为正确 */
.arrangement-remarks-wrapper .section-title-button-group,
#seat-modification-section .section-title-button-group {
    display: flex;
    justify-content: space-between;
    align-items: baseline; /* 修改对齐方式为基线对齐 */
    margin-bottom: 8px; /* 标题组和下方文本框的间距 */
}

.arrangement-remarks-wrapper .section-title-button-group label,
#seat-modification-section .section-title-button-group h3 {
    margin-top: 0; /* 确保顶部无外边距 */
    margin-bottom: 0; /* 移除label/h3自身的下边距，由父级控制 */
    font-weight: 600;
    font-size: 1.1rem; /* 统一标题字体大小 */
    color: #34495e;   /* 统一标题颜色 */
    line-height: 1.5; /* 统一行高 */
    padding-top: 5px; /* 添加一些内边距以帮助对齐 */
    padding-bottom: 5px; /* 添加一些内边距以帮助对齐 */
}

#seat-modification-section .section-title-button-group h3 {
    /* 如果需要更细致的调整h3使其看起来和label完全一样，可以在这里添加，但通常font-weight, size, color已足够 */
}

.inline-button { /* 新增：用于标题旁边按钮的样式 */
    padding: 6px 12px;
    font-size: 0.9rem;
    margin-left: 10px; /* 按钮和标题的间距 */
    flex-shrink: 0; /* 防止按钮被压缩 */
    align-self: center; /* 尝试让按钮在交叉轴居中，配合 baseline 可能有帮助 */
}


.arrangement-remarks-wrapper textarea,
#seat-modification-section textarea {
    width: 100%; 
    box-sizing: border-box; /* padding和border包含在宽度内 */
    min-height: 90px; /* 一致的最小高度 */
}

/* 如果之前#seat-modification-section有特定的边距/内边距/边框覆盖，现在移除它们，除非确实需要 */
#seat-modification-section {
    padding: 15px; /* 确保内边距一致 */
    border: 1px solid #e0e0e0; /* 确保边框一致 */
    border-radius: 8px;
    background-color: #f9f9f9;
}

/* ai-arrange-button 现在在 generator-buttons 中，此规则可能不再直接适用或需要调整 */
/* .table-generator-section .arrangement-section button#ai-arrange-button {
    width: 100%; 
    margin-top: 5px; 
} */


/* Output Areas */
#markdown-output, #table-preview {
    border: 1px solid #e0e0e0;
    padding: 15px;
    border-radius: 8px;
    background-color: #ffffff;
    min-height: 120px; /* Base min-height, specific overrides might apply */
    overflow-x: auto; 
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
}

#markdown-output {
    /* 这里可以添加特定于markdown输出的样式 */
    flex-grow: 1;
    min-height: 0;
    overflow-y: auto;
    /* 覆盖通用样式中的min-height */
    min-height: 0 !important;
}

/* Specific styles for #table-preview to handle vertical growth and scrolling */
#table-preview {
    /* flex-grow: 1; Removed as per new requirement */
    /* overflow-y: auto; Removed to allow content to define height */
    /* min-height: 0; Removed to allow content to define height */
    display: flex; 
    flex-direction: column;
    flex-shrink: 0; /* 确保表格预览区域不会被压缩 */
    /* overflow-x: auto; is handled by a more general rule below if needed */
}

/* Markdown Table Styles */
#markdown-output table, #table-preview table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 10px;
    border: 1px solid #ddd; /* Default border for all sides */
    border-radius: 6px;
    border-right: 3px solid rgb(132 180 255 / 70%); /* Deep blue, 50% opacity */
    border-bottom: 3px solid rgb(132 180 255 / 70%); /* Deep blue, 50% opacity */
    /* Adjust padding if border makes content too close to edge, or use box-sizing: border-box if not already default for tables */
}

#markdown-output th, #markdown-output td, #table-preview th, #table-preview td {
    padding: 10px 12px;
    text-align: left;
    border-bottom: 1px solid #eee;
}
#markdown-output td:not(:last-child), #table-preview td:not(:last-child) {
    border-right: 1px solid #eee; 
}


#markdown-output th, #table-preview th {
    background-color: #f8f9fa;
    font-weight: 600; 
    color: #454d55; 
    border-bottom: 2px solid #dee2e6; 
}
#markdown-output th:not(:last-child), #table-preview th:not(:last-child) {
    border-right: 1px solid #dee2e6; 
}


#markdown-output tr:last-child td, #table-preview tr:last-child td {
    border-bottom: none;
}

#markdown-output tr:nth-child(even) td, #table-preview tr:nth-child(even) td {
    background-color: #f9f9f9; 
}

/* Layout for Output and Table Generator */
.content-wrapper {
    display: flex; 
    gap: 30px;
    align-items: flex-start; /* Allow children to determine their own height */
    flex-grow: 1; /* Allow it to take available vertical space in .container */
    min-height: 0; /* Important for a flex item that grows, to allow shrinking if needed */
    /* overflow: hidden; /* Consider if clipping is desired for the wrapper itself */
}

.output-section {
    /* display: flex; flex-direction: column; is already set by generic section styles */
    flex: 1 1 50%; /* grow, shrink, basis - for 50/50 split when not collapsed */
    min-width: 320px; /* Keep a min-width for responsiveness */
    transition: width 0.3s ease-in-out, min-width 0.3s ease-in-out, padding 0.3s ease-in-out, flex 0.3s ease-in-out; /* Updated transition */
    overflow-y: auto; /* 人员信息表在空间不足时显示滚动条 */
    align-self: stretch; /* Make output-section stretch to the height of table-generator-section */
}

.table-generator-section {
    flex: 1 1 50%; /* grow, shrink, basis - for 50/50 split when not collapsed */
    min-width: 320px;
    transition: flex 0.3s ease-in-out; /* Updated transition */
    /* display: flex; flex-direction: column; is already set by generic section styles */
}


@media (max-width: 767px) { 
    .content-wrapper {
        flex-direction: column;
    }
    .output-section, .table-generator-section {
        width: 100%; 
        flex-basis: auto; 
        min-height: auto; /* Reset min-height for stacked view if 800px is too much */
    }
    .output-section {
        min-height: 400px; /* Or a more suitable min-height for mobile */
    }
}


#ai-thinking-output,
.personnel-thinking-output,
.seat-modify-thinking-output {
    padding: 15px;
    background-color: transparent; 
    border: 2px dashed #cccccc; 
    border-radius: 8px;
    margin-top: 10px;
    margin-bottom: 15px; /* 为移动后的元素添加底部外边距 */
    display: none; 
    opacity: 0; 
    transition: opacity 0.3s ease-in-out;
    flex-shrink: 0; /* 思考过程区域不可压缩 */
}

.thinking-output-visible { 
    display: block !important;
    opacity: 1 !important;
}

#ai-thinking-output h3,
.personnel-thinking-output h3,
.seat-modify-thinking-output h3 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.1rem;
    color: #5f626b; 
    border-bottom: 1px solid #ddd;
    padding-bottom: 5px;
}

#ai-thinking-output pre,
.personnel-thinking-output pre,
.seat-modify-thinking-output pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 200px;
    overflow-y: auto;
    /* New/Modified properties */
    overflow-x: auto; /* Add horizontal scroll if content is too wide */
    max-width: 100%; /* Ensure pre does not exceed its container's width */
    box-sizing: border-box; /* Include padding and border in the element's total width and height */
    /* End New/Modified properties */
    background-color: transparent;
    padding: 10px;
    border-radius: 6px;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    font-size: 0.9rem;
    color: #777777; 
    border: none; 
    opacity: 0;
    animation: fadeInText 0.3s ease-in-out forwards;
    animation-delay: 0.1s; 
}

@keyframes fadeInText {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Agent Thinking Output - similar to other thinking outputs */
.agent-thinking-output {
    padding: 10px 15px; /* Consistent with other thinking outputs but might need adjustment based on sidebar context */
    background-color: transparent; 
    border: 2px dashed #cccccc; 
    border-radius: 8px;
    margin-bottom: 10px; /* Space before chat messages */
    display: none; 
    opacity: 0; 
    transition: opacity 0.3s ease-in-out;
    flex-shrink: 0; /* 思考过程区域不可压缩 */
    overflow-x: hidden; /* Prevent horizontal overflow from children */
}
.agent-thinking-output.thinking-output-visible { /* To show it */
    display: block !important;
    opacity: 1 !important;
}
.agent-thinking-output h3 {
    margin-top: 0;
    margin-bottom: 8px;
    font-size: 1rem; /* Slightly smaller for sidebar context */
    color: #5f626b; 
    border-bottom: 1px solid #ddd;
    padding-bottom: 4px;
}
.agent-thinking-output pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 100px; /* Smaller max-height for sidebar */
    overflow-y: auto;
    background-color: transparent; 
    padding: 8px;
    border-radius: 6px;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    font-size: 0.85rem; /* Smaller font for sidebar */
    color: #777777; 
    border: none; 
    opacity: 0;
    animation: fadeInText 0.3s ease-in-out forwards;
    animation-delay: 0.1s; 
}


/* Styles for special seat modification commands */
.seat-mod-command {
    font-weight: bold;
    padding: 2px 4px;
    border-radius: 3px;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
}
.seat-mod-swap { background-color: #e6f3ff; color: #0056b3; border: 1px solid #b3d9ff; } 
.seat-mod-move { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; } 
.seat-mod-empty { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; } 
.seat-mod-fill { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; } 
.seat-mod-error { background-color: #f8d7da; color: #721c24; font-weight: normal; } 
.seat-mod-message { color: #5f626b; font-style: italic; } 


/* Footer */
#footer {
    text-align: center;
    padding: 15px;
    background-color: #34495e;
    color: #ecf0f1;
    width: 100%;
    box-sizing: border-box;
    opacity: 0;
    transition: opacity 0.5s ease;
    margin-top: auto; 
}

#footer p {
    margin: 0;
    font-size: 0.9rem;
    color: #181818; /* Changed color */
}

#footer a {
    color: #417ceb;
    text-decoration: none;
}

#footer a:hover {
    text-decoration: underline;
}

/* Sidebar Styles */
.sidebar {
    width: 350px; 
    height: 100vh; 
    position: fixed; 
    top: 0;
    right: -350px; 
    background-color: #fdfdfd;
    box-shadow: -2px 0 8px rgba(0,0,0,0.1); 
    z-index: 1000; 
    overflow-y: auto;
    overflow-x: hidden;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 15px;
    transition: right 0.3s ease-in-out, margin-right 0.3s ease-in-out; /* Added margin-right transition */
    flex-shrink: 0;
}

.sidebar.open {
    right: 0;
}

/* This class will be added to .container when a sidebar is open to adjust its width */
.container.sidebar-open-content-shift {
    /* width: calc(100% - 350px); /* This will be set by JavaScript */
    /* margin-right: 350px; /* This might still be needed if buttons are outside .container but inside .container-wrapper */
}


.sidebar-header {
    display: flex;
    /* justify-content: space-between; /* Adjusted for new close button */
    align-items: center;
    padding-bottom: 10px;
    border-bottom: 2px solid #417ceb;
    margin-bottom: 0;
    /* position: relative; /* Ensure header can be a positioning context if needed, but button is now outside */
}

.close-sidebar-button {
    position: absolute;
    top: 25px; /* Vertically align with header text */
    right: 20px; /* Position to the top-right */
    background: transparent;
    border: none;
    color: #5f626b;
    font-size: 28px; /* Size of the '×' character */
    font-weight: bold;
    line-height: 1; /* Ensure tight vertical fit */
    padding: 0;
    cursor: pointer;
    z-index: 1005; 
}

.close-sidebar-button:hover {
    color: #000;
}

.sidebar-header h2 {
    margin: 0;
    font-size: 1.4rem; 
    color: #34495e;
    border-bottom: none;
    padding-bottom: 0;
    /* flex-grow: 1; /* Optional: if title needs to expand */
}

.sidebar .close-button { /* This rule seems to be for a different close button, keeping it for now but the new one is .close-sidebar-button */
     color: #999;
     font-size: 26px;
     font-weight: bold;
     cursor: pointer;
     padding: 0 5px; 
}
.sidebar .close-button:hover {
    color: #333;
}

.sidebar-content {
    display: flex;
    flex-direction: column;
    gap: 20px; 
}

/* Agent对话界面样式 */
.agent-chat-section {
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative; /* Needed for ::before positioning */
    overflow: hidden; /* To contain the pseudo-element if it's larger */
}

.agent-chat-section::before {
    content: "";
    position: absolute;
    bottom: 190px;  /* 显著向上移动，使其底部在输入框附近 */
    right: -150px; /* 配合cover和新的宽高调整 */
    width: 400px;   /* 调整伪元素尺寸 */
    height: 390px;  /* 调整伪元素尺寸 */
    background-image: url('images/logo.png');
    background-repeat: no-repeat;
    background-size: cover; /* 改为cover以填充并消除白边，可能会裁剪 */
    opacity: 0.3;
    z-index: -1; /* 置于父元素背景之下 */
    pointer-events: none; /* 确保不干扰点击 */
}

.agent-chat-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 500px;
}

.agent-chat-messages {
    flex-grow: 1;
    /* border: 1px solid #e0e0e0; Removed border */
    /* border-radius: 8px; Removed border-radius */
    padding: 0; /* Adjusted padding, or remove if handled by individual messages */
    /* background-color: #f8f9fa; Removed background, will inherit from sidebar-content */
    overflow-y: auto;
    margin-bottom: 15px; /* Keep space before input area */
    display: flex;
    flex-direction: column; 
    gap: 12px;
    position: relative; /* Ensure messages are above the ::before pseudo-element of parent */
    z-index: 1;
}

.agent-message {
    padding: 12px 15px; /* Increased padding */
    border-radius: 10px; /* More rounded corners */
    position: relative;
    max-width: 85%; /* Messages don't take full width */
    word-wrap: break-word; /* Ensure long words break */
    line-height: 1.5;
}

.agent-message.user-message {
    background-color: #e2f0d9; /* 用户消息背景 - 浅绿色 */
    border: 1px solid #c3e6cb;
    color: #155724;
    align-self: flex-end; /* 用户消息靠右 */
    border-left: none; 
    border-right: 4px solid #28a745; /* 右侧绿色强调线 */
    margin-left: auto; 
    margin-right: 5px; 
}

.agent-message.agent-message-assistant, 
.agent-message.assistant-message { 
    background-color: #d1e7fd; /* Agent消息背景 - 浅蓝色 */
    border: 1px solid #b8daff;
    color: #0c5460;
    align-self: flex-start; /* Agent消息靠左 */
    border-right: none; 
    border-left: 4px solid #007bff; /* 左侧蓝色强调线 */
    margin-right: auto; 
    margin-left: 5px; 
}
.agent-message.agent-message-error, /* For error messages from agent */
.agent-message.error-message {
    background-color: #f8d7da; /* Light red for errors */
    border: 1px solid #f5c6cb;
    color: #721c24;
    border-left: 4px solid #dc3545; /* Red accent */
    align-self: flex-start;
    margin-right: auto;
    margin-left: 5px;
}


.agent-message-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px; /* Space between header and content */
    font-size: 0.85rem;
    color: #5f626b;
}
.agent-message-header strong {
    font-weight: 600;
}
.agent-message-time {
    font-size: 0.75rem;
    color: #777;
}

.agent-message-content {
    /* margin-bottom: 5px; Handled by agent-message padding */
    /* line-height: 1.5; Moved to .agent-message */
    /* word-wrap: break-word; Moved to .agent-message */
}


.agent-chat-input-area {
    flex-shrink: 0;
    position: relative; /* Ensure it's above the ::before pseudo-element */
    z-index: 1;         /* Ensure it's above the ::before pseudo-element */
    padding-top: 15px; /* Add some space above input area */
    border-top: 1px solid #e0e0e0; /* Separator line */
    background-color: #fdfdfd; /* Match sidebar background */
    margin: 0 -20px -20px -20px; /* Extend to sidebar edges */
    padding: 15px 20px 20px 20px; /* Inner padding */
}

.agent-chat-input-area textarea {
    margin-bottom: 10px;
    resize: vertical;
    min-height: 70px; /* Slightly taller input */
    border-radius: 8px; /* Rounded corners for textarea */
    border: 1px solid #ced4da;
    padding: 10px;
}
.agent-chat-input-area textarea:focus {
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

.agent-chat-input-buttons {
    display: flex;
    gap: 10px;
    /* justify-content: flex-end; /* Removed to allow buttons to fill width */
}

.agent-chat-input-buttons button {
    flex: 1 1 0; /* Allow buttons to grow and shrink equally */
    padding: 8px 15px; 
    font-size: 0.95rem;
}

/* Specific button styling if needed, e.g., for primary send button */
#agent-send-button {
    background-color: #007bff; /* Blue send button */
}
#agent-send-button:hover {
    background-color: #0056b3;
}
#agent-clear-button {
    background-color: #6c757d; /* Grey clear button */
}
#agent-clear-button:hover {
    background-color: #545b62;
}


/* Agent配置区域样式 - Kept for now, but not primary focus of this change */
.agent-config-section {
    border-top: 1px solid #eee;
    padding-top: 15px;
    margin-top: 15px;
}

.agent-config-section textarea {
    min-height: 80px;
}

.agent-config-section input[type="number"] {
    width: 100px;
}

/* Ensure primary and secondary button classes are available if used by agent controls */
.primary-button { /* General primary button style if needed elsewhere */
    background-color: #007bff;
}
.primary-button:hover {
    background-color: #0056b3;
}
.secondary-button { /* General secondary button style */
    background-color: #6c757d;
}
.secondary-button:hover {
    background-color: #5a6268;
}

.active-config-display {
    background-color: #e9f5ff;
    border: 1px solid #b3d9ff;
    padding: 10px 12px;
    border-radius: 6px;
    font-size: 0.9rem;
    color: #0056b3;
}
.active-config-display p { margin: 0; font-weight: 500; }
.active-config-display strong { color: #004085; }

.config-item-header {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between; 
}
.config-item-header h3 {
    margin: 0; 
    display: flex;
    align-items: center;
    gap: 8px; 
    font-size: 1.1rem;
    color: #34495e;
}
.collapse-icon {
    font-size: 0.8em;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.model-config-item.collapsed .collapse-icon {
    transform: rotate(-90deg);
}

.model-config-item > .config-item-content { 
    max-height: 1000px; 
    overflow: hidden;
    opacity: 1;
    transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1), 
                opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                margin-top 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                padding-top 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                padding-bottom 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    padding-top: 10px; 
    padding-bottom: 10px;
    margin-top: 10px; 
}

.model-config-item.collapsed > .config-item-content {
    max-height: 0;
    opacity: 0;
    padding-top: 0;
    padding-bottom: 0;
    margin-top: 0;
}
.active-indicator {
    font-size: 0.8rem;
    color: #27ae60;
    font-weight: bold;
    margin-left: auto; 
}


.deepseek-quick-config, #model-configs-list {
    padding-top: 15px;
    border-top: 1px solid #eee;
}
.deepseek-quick-config:first-child, #model-configs-list:first-child {
     border-top: none;
     padding-top: 0;
}


.deepseek-quick-config h3 { 
    margin-top: 0;
    margin-bottom: 12px;
    font-size: 1.1rem;
    color: #34495e;
}

.model-config-item {
    border: 1px solid #ddd;
    padding: 15px;
    margin-bottom: 10px;
    border-radius: 8px;
    background-color: #f9f9f9;
    display: flex;
    flex-direction: column;
    gap: 10px;
    transition: border-color 0.3s ease;
}
.model-config-item.active-config {
    border-color: #27ae60; 
    box-shadow: 0 0 8px rgba(39, 174, 96, 0.3);
}

.config-item-content { 
    display: flex;
    flex-direction: column;
    gap: 10px; 
}


.model-config-item label {
    margin-bottom: 3px; 
    font-weight: 500; 
}

.model-config-item input[type="text"],
.model-config-item input[type="password"],
.model-config-item select {
    width: 100%; 
    padding: 8px;
    margin-bottom: 5px; 
}

.custom-select-wrapper {
    position: relative;
    width: 100%;
}

.custom-select-trigger {
    width: 100%;
    padding: 10px;
    background-color: #fff;
    border: 1px solid #ccc;
    border-radius: 6px;
    text-align: left;
    cursor: pointer;
    font-size: 1rem; 
    color: #333; 
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-sizing: border-box;
}
.custom-select-trigger::after { 
    content: '▼';
    font-size: 0.7em;
    margin-left: 8px;
}
.custom-select-wrapper.open .custom-select-trigger::after {
    content: '▲';
}

.custom-select-dropdown {
    display: none; 
    position: absolute;
    top: 100%; 
    left: 0;
    right: 0;
    background-color: #fff;
    border: 1px solid #ccc;
    border-top: none; 
    border-radius: 0 0 6px 6px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    z-index: 1050; 
    padding: 8px;
    box-sizing: border-box;
}
.custom-select-wrapper.open .custom-select-dropdown {
    display: block;
}

.custom-select-dropdown .model-search-input { 
    width: 100%;
    padding: 8px;
    margin-bottom: 8px; 
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
    box-sizing: border-box;
}
.custom-select-dropdown .model-search-input:focus {
    border-color: #417ceb;
    box-shadow: 0 0 6px rgba(65, 124, 235, 0.2);
    outline: none;
}

.custom-options-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 150px; 
    overflow-y: auto;
}

.custom-options-list li {
    padding: 8px 10px;
    cursor: pointer;
    font-size: 0.95rem;
    border-radius: 4px;
}

.custom-options-list li:hover,
.custom-options-list li.selected { 
    background-color: #d6eaff; /* 改为浅蓝色 */
}
.custom-options-list li.hidden-by-search {
    display: none;
}


.model-config-item .models-list {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #ccc;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.model-item {
    border: 1px dashed #ccc;
    padding: 10px;
    border-radius: 6px;
    background-color: #fff;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.model-item label { font-weight: normal; color: #666; }
.model-item input[type="text"], .model-item select { padding: 7px; margin-bottom: 5px; }
.model-item select[multiple] { height: 70px; }

.model-config-item .config-actions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.model-config-item .config-actions button {
    flex-grow: 1;
    padding: 8px 10px;
    font-size: 0.9rem;
}

button.primary-button { background-color: #417ceb; }
button.primary-button:hover { background-color: #3562d4; }
button.primary-button:disabled { background-color: #d7dffc; color: #777; }


button.secondary-button { background-color: #9fafc0; }
button.secondary-button:hover { background-color: #7f8c8d; }

button.danger-button { background-color: #e74c3c; }
button.danger-button:hover { background-color: #c0392b; }

.model-item button.remove-model, 
.model-config-item button.add-model, 
#add-model-config, 
.deepseek-quick-config button { 
    width: 100%; 
    padding: 9px;
    font-size: 0.95rem;
}
.model-item button.remove-model { background-color: #e74c3c; }
.model-item button.remove-model:hover { background-color: #c0392b; }


.model-list-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}
.model-list-controls h4 { margin: 0; font-size: 1rem; }
.model-list-controls .fetch-models {
     padding: 6px 10px;
     background-color: #5bc0de;
     color: white;
     font-size: 0.9rem;
     width: auto; 
}
.model-list-controls .fetch-models:hover { background-color: #46b8da; }


/* Responsive adjustments */
@media (max-width: 768px) {
    .container {
        padding: 20px;
        margin: 20px 10px; 
        gap: 20px;
    }

    h1 { font-size: 2rem; }
    h2 { font-size: 1.5rem; }

    .input-section #send-description,
    .output-section .controls,
    .table-generator-section .generator-buttons,
    .table-generator-section .arrangement-section, /* Changed from .arrangement-controls */
    .table-generator-section #copy-arranged-table { /* This ID might be inside .generator-buttons now */
        flex-direction: column; 
        align-items: stretch; 
    }
    .input-section #send-description,
    .table-generator-section .arrangement-section button, /* Target button inside .arrangement-section */
    .table-generator-section #copy-arranged-table {
        width: 100%; 
    }
    .output-section .controls button {
        flex-grow: 0; 
    }
     .table-generator-section .generator-controls {
        flex-direction: column;
        align-items: stretch;
    }
    .table-generator-section .generator-controls input[type="number"] {
        width: 100%;
    }
}

/* In-page Notification Area */
#in-page-notification-area {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 10000; /* Ensure it's above most other content */
    width: 300px; /* Or max-width, adjust as needed */
}

/* Individual Notification Styling */
.in-page-notification {
    padding: 12px 18px;
    margin-bottom: 10px;
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    opacity: 0;
    transform: translateX(100%);
    transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
    font-size: 0.9rem;
    line-height: 1.4;
    color: #fff; /* Default text color, can be overridden by type */
}

.in-page-notification.show {
    opacity: 1;
    transform: translateX(0);
}

/* Notification Types */
.in-page-notification.info {
    background-color: #17a2b8; /* Bootstrap info color */
    border-left: 5px solid #117a8b;
}

.in-page-notification.success {
    background-color: #28a745; /* Bootstrap success color */
    border-left: 5px solid #1e7e34;
}

.in-page-notification.warning {
    background-color: #ffc107; /* Bootstrap warning color */
    color: #212529; /* Darker text for yellow background */
    border-left: 5px solid #d39e00;
}

.in-page-notification.error {
    background-color: #dc3545; /* Bootstrap danger color */
    border-left: 5px solid #bd2130;
}


/* Dark mode scrollbar styling */
/* Scrollbar Styles */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
::-webkit-scrollbar-thumb { background: #aaa; border-radius: 10px; }
::-webkit-scrollbar-thumb:hover { background: #777; }

/* Gender coloring - already present, kept for completeness */
.gender-male { background-color: #e6f3ff; }
.gender-female { background-color: #ffe6f2; }

/* Personnel List Collapsing Styles */
.personnel-list-wrapper {
    transition: width 0.3s ease-in-out, padding 0.3s ease-in-out;
    overflow: hidden; 
    width: 100%; 
    flex-grow: 1; /* Allow wrapper to grow to fill .output-section */
    overflow-y: auto; /* Always allow scroll if content overflows */
    min-height: 0; /* Important for flex item to shrink correctly */
    display: flex;
    flex-direction: column;
}

.output-section:not(.personnel-collapsed) .personnel-list-wrapper {
    /* flex-grow: 1; Already set above */
    /* overflow-y: auto; Already set above */
    overflow-x: visible; 
    /* min-height: 0; Already set above */
}

.output-section.personnel-collapsed .personnel-list-wrapper {
    /* width: 100%; Already set by general .personnel-list-wrapper */
    padding: 0; 
    /* overflow-y: auto; Already set by general .personnel-list-wrapper */
    /* flex-grow: 1; Already set by general .personnel-list-wrapper */
    /* min-height: 0; Already set by general .personnel-list-wrapper */
}


.output-section.personnel-collapsed {
    width: 110px; /* Increased width */
    max-width: 120px; /* Consistent with new width */
    min-width: 100px; /* Consistent with new width, or adjust as needed */
    padding: 10px 5px; /* Adjusted padding slightly */
    flex: 0 0 150px; /* Do not grow, do not shrink, basis is 150px */
    min-height: 100px; /* Explicit small min-height when collapsed */
    /* min-height: 800px; will apply unless overridden by media query */
}

/* Styles for the new div-based list in collapsed mode */
.output-section.personnel-collapsed .personnel-list-wrapper #markdown-output .personnel-item {
    padding: 8px 5px;
    font-size: 0.9em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    cursor: default;
    position: relative; 
    border-bottom: 1px solid #eee; 
}
.output-section.personnel-collapsed .personnel-list-wrapper #markdown-output .personnel-item:last-child {
    border-bottom: none;
}
.output-section.personnel-collapsed .personnel-list-wrapper #markdown-output .personnel-item-empty {
    padding: 8px 5px;
    font-size: 0.9em;
    color: #777;
    text-align: center;
}


/* Tooltip for collapsed view (now targets .personnel-item) - REMOVED */
/*
.output-section.personnel-collapsed .personnel-list-wrapper #markdown-output .personnel-item:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    left: 105%; 
    top: 50%;
    transform: translateY(-50%);
    background-color: #333;
    color: #fff;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 0.85em;
    white-space: pre-wrap; 
    z-index: 1001; 
    margin-left: 5px; 
    min-width: 150px; 
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    pointer-events: none; 
    display: block !important; 
    opacity: 1 !important; 
    visibility: visible !important; 
}
*/

/* Hide input area and controls except the toggle button when collapsed */
.output-section.personnel-collapsed .personnel-input-area {
    display: none;
}
.output-section.personnel-collapsed .personnel-controls {
    display: none;
}
.output-section.personnel-collapsed .loading-indicator {
    display: none;
}
.output-section.personnel-collapsed .personnel-thinking-output {
    display: none;
}
.output-section.personnel-collapsed .import-personnel-section {
    display: none;
}
.output-section.personnel-collapsed .controls button:not(#toggle-personnel-list) {
    display: none;
}
.output-section.personnel-collapsed .controls {
    justify-content: center; 
}
.output-section.personnel-collapsed h2,
.output-section.personnel-collapsed .import-personnel-section { 
    display: none;
}
.output-section.personnel-collapsed #loading { 
    display: none !important;
}

/* Styles for table cells in expanded view (if tooltip is also desired there on name) */
#markdown-output table td:first-child {
    position: relative; 
}
/* Optional: Tooltip for expanded view table cells (if desired) - REMOVED */
/*
#markdown-output table td:first-child:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    left: 0; 
    top: 100%; 
    background-color: #333;
    color: #fff;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 0.85em;
    white-space: pre-wrap; 
    z-index: 1001; 
    margin-top: 2px; 
    min-width: 200px; 
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    pointer-events: none; 
    display: block !important; 
    opacity: 1 !important; 
    visibility: visible !important; 
}
*/
/* Add word-wrap for table cells, especially remarks, to prevent overflow */
#markdown-output td {
    word-wrap: break-word; 
    overflow-wrap: break-word; 
}


/* Adjust table generator section when personnel list is collapsed */
.content-wrapper.personnel-list-collapsed .table-generator-section { /* 确保此规则存在且正确 */
    flex-grow: 1;
    flex-shrink: 1; /* Allow shrinking if needed */
    flex-basis: auto; /* Take up remaining space */
    width: auto; /* Let flexbox determine width */
}

/* Removed .content-wrapper:not(.personnel-list-collapsed) .table-generator-section rule as it's handled by the default .table-generator-section flex property */


/* Ensure the controls button for toggle has appropriate styling if needed */
#toggle-personnel-list {
    min-width: 80px; 
}
.output-section.personnel-collapsed #toggle-personnel-list {
    width: 100%; 
    padding: 10px 5px; 
}

/* Style for original seat number background */
.original-seat-number-bg {
    position: absolute;
    bottom: 2px;
    right: 4px;
    font-size: 0.65em; 
    color: rgba(0, 0, 0, 0.25); 
    z-index: 0; 
    pointer-events: none; 
    font-weight: bold;
}

#table-preview td { 
    position: relative;
}

    </style>
</head>
<body>
    <div class="app-wrapper"> <!-- 新增的包裹层 -->
        <div class="container-wrapper"> <!-- 新增：包裹主内容和浮动按钮 -->
            <div class="container"> <!-- 主内容区域 -->
                <div class="main-header">
                    <h1>DeepDeskmate</h1><p>单文件版(beta)</p>
                    
                <!-- 模型配置按钮将移动到左下角 -->
            </div>
    
    
    
    
            <div class="content-wrapper">
                <div class="output-section"> <!-- This section will get the .personnel-collapsed class -->
                    <div class="section-header-controls"> <!-- Wrapper for title and toggle button -->
                        <h2>人员信息表</h2>
                        <button id="toggle-personnel-list" class="toggle-list-button"><</button> 
                    </div>
                    <div class="description-input-group"> <!-- This will be hidden when collapsed -->
                        <textarea id="person-description" rows="4" placeholder="输入需要整理的人物描述，例如：张三，男，技术负责人，擅长沟通协调。"></textarea>
                    </div>
        
                    <div class="controls">
                        <button id="send-description">AI整理</button>
                        <button id="clear-personnel-table" class="secondary-button">清除</button>
                        <!-- import-personnel-button moved down -->
                        <button id="copy-personnel-info" class="secondary-button">复制</button>
                        <!-- toggle-personnel-list button moved up -->
                    </div>
                    <div class="loading-indicator" id="loading" style="display: none;">
                        AI 正在处理中...
                    </div>
                    <div id="loading" style="display: none;">AI正在思考...</div>
                    <div class="personnel-thinking-output"> <!-- 新增：人员信息处理的思考过程 -->
                        <h3>AI 思考过程...</h3>
                        <pre></pre>
                    </div>
                    <div id="markdown-output-wrapper" class="personnel-list-wrapper"> <!-- 包裹 markdown-output -->
                        <div id="markdown-output"></div>
                    </div>
                    
                    <div class="import-personnel-section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
                        <div class="section-subheader-with-button">
                            <h3>导入人员信息表 (Markdown格式)</h3>
                            <button id="import-personnel-button" class="secondary-button inline-button">导入</button>
                        </div>
                        <textarea id="import-personnel-markdown" rows="6" placeholder="在此粘贴人员信息的Markdown表格，例如：\n| 人物 | 性别 | 备注 |\n| --- | --- | --- |\n| 张三 | 男 | 技术部 |\n| 李四 | 女 | 产品部 |"></textarea>
                    </div>
                </div>
    
                <div class="table-generator-section">
                    <h2>座位列表生成器</h2>
                    <div class="generator-controls">
                        <label for="rows">行数:</label>
                        <input type="number" id="rows" min="1" value="8">
                        <label for="cols">列数:</label>
                        <input type="number" id="cols" min="1" value="7">
                        <label for="desk-mates">同桌数:</label>
                        <input type="number" id="desk-mates" min="1" value="2">
                        <div class="generator-buttons">
                            <!-- <button id="ai-arrange-button">AI 智能编排</button> --> <!-- 按钮将移动 -->
                            <button id="copy-arranged-table" class="secondary-button">复制编排结果</button>
                            <!-- <button id="send-seat-modification-button" style="display: none;">发送修改指令</button> --> <!-- 按钮将移动 -->
                        </div>
                    </div>
                    <div class="arrangement-section">
                        <div class="arrangement-remarks-wrapper">
                            <div class="section-title-button-group">
                                <label for="arrangement-remarks">编排备注</label>
                                <button id="ai-arrange-button" class="inline-button">AI编排</button>
                            </div>
                            <textarea id="arrangement-remarks" rows="3" placeholder="输入需要 AI 考虑的编排要求，例如：王五视力不好，请安排在前排。"></textarea>
                        </div>
                        
                        <div id="seat-modification-section" class="seat-modification-section" style="display: none;">
                            <div class="section-title-button-group">
                                <h3>细微调整座位</h3>
                                <button id="send-seat-modification-button" class="inline-button" style="display: none;">发送</button>
                            </div>
                            <textarea id="seat-modification-input" rows="3" placeholder="输入需要微调的部分，例如：请将张三和王五调换位置。李四想坐窗边。"></textarea>
                            
                            <div id="seat-modification-loading" style="display: none;">AI 正在处理修改...</div>
                            <!-- seat-modify-thinking-output 和 seat-modification-output 将被移动 -->
                        </div>
                    </div>
                    <!-- 座位编排的思考过程 -->
                    <div id="ai-thinking-output"> 
                        <h3>AI 编排思考过程...</h3>
                        <pre></pre> 
                    </div>
                    <!-- 座位微调的思考过程 -->
                    <div class="seat-modify-thinking-output" style="display: none;"> 
                        <h3>AI 微调思考过程...</h3>
                        <pre></pre>
                    </div>
                    <!-- 座位微调结果 -->
                    <div id="seat-modification-output" style="margin-top:10px; padding:10px; border:1px dashed #ccc; border-radius:4px; display:none;"></div>
                    <!-- arrangement-actions div removed as its content moved -->
                    <div id="table-preview"></div>
    
                    <div class="import-seat-table-section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
                        <div class="section-subheader-with-button">
                            <h3>导入座位表 (Markdown格式)</h3>
                            <button id="import-seat-table-button" class="secondary-button inline-button">导入</button>
                        </div>
                        <textarea id="import-seat-table-markdown" rows="6" placeholder="在此粘贴座位表的Markdown，AI将基于此进行修改。"></textarea>
                    </div>
                </div>
            </div>
            <!-- 新的侧边栏触发按钮现在位于 container-wrapper 内部，但在 container 外部 -->
            <button id="sidebar-toggle-button" class="sidebar-toggle-button settings-button">⚙️</button>
            <button id="open-agent-button" class="sidebar-toggle-button agent-button">🤖</button>
        </div> <!-- container-wrapper 结束 -->
    
        <!-- 模型配置侧边栏 -->
        <aside id="settings-sidebar" class="sidebar closed">
            <button type="button" class="close-sidebar-button" aria-label="关闭模型配置侧边栏">&times;</button>
            <div class="sidebar-header">
                <h2>模型配置</h2>
            </div>
            <div class="sidebar-content">
                <!-- DeepSeek 快速配置 -->
                <div class="config-section deepseek-quick-config">
                    <h3>DeepSeek 快速配置</h3>
                    <input type="password" id="deepseek-api-key" placeholder="在此输入 DeepSeek API Key">
                    <button id="quick-config-deepseek">快速配置 DeepSeek</button>
                </div>
    
                <!-- 使用模型配置板块 -->
                <div class="config-section model-usage-settings">
                    <h3>使用模型选择</h3>
                    <div class="model-selection-group">
                        <label for="info-model-trigger">信息整理模型:</label>
                        <div class="custom-select-wrapper">
                            <button type="button" id="info-model-trigger" class="custom-select-trigger" data-dropdown-id="info-model-dropdown">--选择模型--</button>
                            <div class="custom-select-dropdown" id="info-model-dropdown">
                                <input type="text" class="model-search-input" placeholder="搜索模型...">
                                <ul class="custom-options-list"></ul>
                            </div>
                        </div>
                        <input type="hidden" id="info-model-select-value" name="infoModelValue">
                    </div>
                    <div class="model-selection-group">
                        <label for="seating-model-trigger">座位表生成模型:</label>
                        <div class="custom-select-wrapper">
                            <button type="button" id="seating-model-trigger" class="custom-select-trigger" data-dropdown-id="seating-model-dropdown">--选择模型--</button>
                            <div class="custom-select-dropdown" id="seating-model-dropdown">
                                <input type="text" class="model-search-input" placeholder="搜索模型...">
                                <ul class="custom-options-list"></ul>
                            </div>
                        </div>
                        <input type="hidden" id="seating-model-select-value" name="seatingModelValue">
                    </div>
                    <div class="model-selection-group">
                        <label for="seat-modify-model-trigger">座位微调模型:</label>
                        <div class="custom-select-wrapper">
                            <button type="button" id="seat-modify-model-trigger" class="custom-select-trigger" data-dropdown-id="seat-modify-model-dropdown">--选择模型--</button>
                            <div class="custom-select-dropdown" id="seat-modify-model-dropdown">
                                <input type="text" class="model-search-input" placeholder="搜索模型...">
                                <ul class="custom-options-list"></ul>
                            </div>
                        </div>
                        <input type="hidden" id="seat-modify-model-select-value" name="seatModifyModelValue">
                    </div>
                    <div class="model-selection-group">
                        <label for="agent-model-trigger">Agent驱动模型:</label>
                        <div class="custom-select-wrapper">
                            <button type="button" id="agent-model-trigger" class="custom-select-trigger" data-dropdown-id="agent-model-dropdown">--选择模型--</button>
                            <div class="custom-select-dropdown" id="agent-model-dropdown">
                                <input type="text" class="model-search-input" placeholder="搜索模型...">
                                <ul class="custom-options-list"></ul>
                            </div>
                        </div>
                        <input type="hidden" id="agent-model-select-value" name="agentModelValue">
                    </div>
                    <button id="save-model-usage-button">保存模型选择</button>
                </div>
                <!-- 提供商配置板块 -->
                <div class="config-section provider-settings">
                    <div class="section-subheader-with-button">
                        <h3>提供商配置</h3>
                        <button id="add-provider-button" class="inline-button">添加提供商</button>
                    </div>
                    <div id="provider-list">
                        <!-- 提供商条目将在这里动态添加 -->
                    </div>
                </div>
            </div>
        </aside>
    
        <!-- Agent 侧边栏 -->
        <aside id="agent-sidebar" class="sidebar closed">
            <button type="button" class="close-sidebar-button" aria-label="关闭Agent侧边栏">&times;</button>
            <div class="sidebar-header">
                <h2>Agent</h2>
            </div>
            <div class="sidebar-content agent-chat-section"> <!-- Added agent-chat-section for flex layout -->
                <!-- Removed agent-thinking-output div, thinking process will be inside message bubbles -->
                <div id="agent-chat-messages" class="agent-chat-messages">
                    <!-- 消息将由JS动态添加 -->
                </div>
                <div class="agent-chat-input-area">
                    <textarea id="agent-chat-input" placeholder="输入您的消息..." rows="3"></textarea>
                    <div class="agent-chat-input-buttons">
                        <button id="agent-send-button">发送</button>
                        <button id="agent-clear-button" class="secondary-button">清空对话</button>
                    </div>
                </div>
                <!-- Agent 配置 (如果需要，可以放在这里或另一个可折叠区域) -->
                <!-- 
                <div class="agent-config-section">
                    <h3>Agent 配置</h3>
                    <label for="agent-system-prompt">系统提示词:</label>
                    <textarea id="agent-system-prompt" rows="3" placeholder="定义Agent的行为和角色..."></textarea>
                    <button id="agent-save-config-button">保存配置</button>
                </div>
                 -->
            </div>
        </aside>
    </div> <!-- app-wrapper 结束 -->
    
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
        <script src="script.js"></script>
    </body>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> 
    <script>
       function showInPageNotification(message, type = 'info') {
    const notificationArea = document.getElementById('in-page-notification-area');
    if (!notificationArea) {
        // If the area doesn't exist, create it dynamically.
        // This is a fallback, ideally it should be in the HTML.
        const newNotificationArea = document.createElement('div');
        newNotificationArea.id = 'in-page-notification-area';
        document.body.appendChild(newNotificationArea);
        // Call again, now that the area should exist.
        // Use a timeout to allow the DOM to update.
        setTimeout(() => showInPageNotification(message, type), 0);
        return;
    }

    const notificationId = `notification-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    const notificationDiv = document.createElement('div');
    notificationDiv.id = notificationId;
    notificationDiv.className = `in-page-notification ${type}`;
    notificationDiv.textContent = message;

    notificationArea.appendChild(notificationDiv);

    // Animate in (requires CSS for .in-page-notification.show)
    setTimeout(() => {
        notificationDiv.classList.add('show');
    }, 50); 

    // Auto-dismiss after 5 seconds
    setTimeout(() => {
        notificationDiv.classList.remove('show');
        // Remove the element after the fade-out animation completes
        setTimeout(() => {
            const el = document.getElementById(notificationId);
            if (el) el.remove();
        }, 500); // Match this duration with CSS transition duration
    }, 5000);
}

// const apiKeyInput = document.getElementById('api-key');
// const saveKeyButton = document.getElementById('save-key');
const personDescriptionInput = document.getElementById('person-description');
const sendDescriptionButton = document.getElementById('send-description');
const loadingIndicator = document.getElementById('loading');
const markdownOutputDiv = document.getElementById('markdown-output');
const markdownOutputWrapper = document.getElementById('markdown-output-wrapper');
const outputSection = document.querySelector('.output-section'); // Parent of markdownOutputWrapper
const contentWrapper = document.querySelector('.content-wrapper'); // Parent of outputSection
const togglePersonnelListButton = document.getElementById('toggle-personnel-list');
// const toggleApiKeyButton = document.getElementById('toggle-api-key');
// const apiKeySection = document.getElementById('api-key-section');
const rowsInput = document.getElementById('rows');
const colsInput = document.getElementById('cols');
const deskMatesInput = document.getElementById('desk-mates');
const tablePreviewDiv = document.getElementById('table-preview');
// const generateTableButton = document.getElementById('generate-table'); // 按钮已被移除或功能合并

// Sidebar elements
const settingsSidebar = document.getElementById('settings-sidebar');
const sidebarToggleButton = document.getElementById('sidebar-toggle-button'); // Settings button
const appWrapper = document.querySelector('.app-wrapper');
const mainContainer = document.querySelector('.container'); // Main content area that shifts
const containerWrapper = document.querySelector('.container-wrapper'); // Parent of .container and buttons

// Agent Sidebar elements
const agentSidebar = document.getElementById('agent-sidebar');
const agentToggleButton = document.getElementById('open-agent-button'); // Corrected ID based on HTML
const agentChatMessages = document.getElementById('agent-chat-messages');
const agentChatInput = document.getElementById('agent-chat-input');
const agentSendButton = document.getElementById('agent-send-button');
const agentClearButton = document.getElementById('agent-clear-button');
const agentSystemPromptTextarea = document.getElementById('agent-system-prompt');
const agentSaveConfigButton = document.getElementById('agent-save-config-button');

// Agent功能相关变量
let agentConversationHistory = []; // Agent对话历史
let agentSystemPrompt = ''; // Agent系统提示词

// DeepSeek Quick Config
const deepseekApiKeyInput = document.getElementById('deepseek-api-key');
const quickConfigDeepseekButton = document.getElementById('quick-config-deepseek');

// Provider Settings
const providerListDiv = document.getElementById('provider-list');
const addProviderButton = document.getElementById('add-provider-button');

// Model Usage Settings - Custom Selects
const infoModelTrigger = document.getElementById('info-model-trigger');
const infoModelDropdown = document.getElementById('info-model-dropdown');
const infoModelSearchInput = infoModelDropdown ? infoModelDropdown.querySelector('.model-search-input') : null;
const infoModelOptionsList = infoModelDropdown ? infoModelDropdown.querySelector('.custom-options-list') : null;
const infoModelSelectValue = document.getElementById('info-model-select-value');

const seatingModelTrigger = document.getElementById('seating-model-trigger');
const seatingModelDropdown = document.getElementById('seating-model-dropdown');
const seatingModelSearchInput = seatingModelDropdown ? seatingModelDropdown.querySelector('.model-search-input') : null;
const seatingModelOptionsList = seatingModelDropdown ? seatingModelDropdown.querySelector('.custom-options-list') : null;
const seatingModelSelectValue = document.getElementById('seating-model-select-value');

const seatModifyModelTrigger = document.getElementById('seat-modify-model-trigger');
const seatModifyModelDropdown = document.getElementById('seat-modify-model-dropdown');
const seatModifyModelSearchInput = seatModifyModelDropdown ? seatModifyModelDropdown.querySelector('.model-search-input') : null;
const seatModifyModelOptionsList = seatModifyModelDropdown ? seatModifyModelDropdown.querySelector('.custom-options-list') : null;
const seatModifyModelSelectValue = document.getElementById('seat-modify-model-select-value');

// Agent驱动模型选择元素 (确保这些ID与HTML中的新部分匹配)
const agentModelTrigger = document.getElementById('agent-model-trigger'); 
const agentModelDropdown = document.getElementById('agent-model-dropdown');
const agentModelSearchInput = agentModelDropdown ? agentModelDropdown.querySelector('.model-search-input') : null;
const agentModelOptionsList = agentModelDropdown ? agentModelDropdown.querySelector('.custom-options-list') : null;
const agentModelSelectValue = document.getElementById('agent-model-select-value');

const saveModelUsageButton = document.getElementById('save-model-usage-button');
const activeConfigDisplayDiv = document.getElementById('active-config-display'); // Re-purposed for showing current task model
const activeConfigStrongElement = activeConfigDisplayDiv ? activeConfigDisplayDiv.querySelector('strong') : null;


const clearPersonnelTableButton = document.getElementById('clear-personnel-table');
const importPersonnelMarkdownTextarea = document.getElementById('import-personnel-markdown');
const importPersonnelButton = document.getElementById('import-personnel-button');
const copyArrangedTableButton = document.getElementById('copy-arranged-table');
const copyPersonnelInfoButton = document.getElementById('copy-personnel-info');
const importSeatTableMarkdownTextarea = document.getElementById('import-seat-table-markdown');
const importSeatTableButton = document.getElementById('import-seat-table-button');

// Seat Modification UI Elements
const seatModificationSection = document.getElementById('seat-modification-section');
const seatModificationInput = document.getElementById('seat-modification-input');
const sendSeatModificationButton = document.getElementById('send-seat-modification-button');
const seatModificationLoading = document.getElementById('seat-modification-loading');
const seatModificationOutput = document.getElementById('seat-modification-output');

let seatModificationConversationHistory = [];
let conversationHistory = [];
let personnelData = JSON.parse(localStorage.getItem('personnel_data') || '[]');

// 新的数据结构
let providers = JSON.parse(localStorage.getItem('llm_providers') || '[]');
let modelUsageSettingsStored = localStorage.getItem('llm_model_usage_settings');
let modelUsageSettings = modelUsageSettingsStored ? JSON.parse(modelUsageSettingsStored) : {
    personnel: null,
    seating: null,
    seat_modification: null,
    agent: null // 新增Agent驱动模型配置
};

// 页面加载时显示已保存的人员信息表
if (personnelData.length > 0) {
    markdownOutputDiv.innerHTML = marked.parse(personnelDataToMarkdown(personnelData));
}

// --- 保存和加载函数 ---
function saveProviders() {
    localStorage.setItem('llm_providers', JSON.stringify(providers));
}

function saveModelUsageSettings() {
    localStorage.setItem('llm_model_usage_settings', JSON.stringify(modelUsageSettings));
}

// --- 提供商配置相关函数 ---
function renderProviders() {
    providerListDiv.innerHTML = '';
    providers.forEach((provider, index) => {
        const providerItem = document.createElement('div');
        providerItem.classList.add('provider-item', 'model-config-item'); // Re-use some styling
        providerItem.dataset.providerId = provider.id;

        // 展开/折叠状态
        const isCollapsed = provider.isCollapsed === undefined ? false : provider.isCollapsed;
        if (isCollapsed) {
            providerItem.classList.add('collapsed');
        }

        providerItem.innerHTML = `
            <div class="config-item-header" data-provider-index="${index}">
                <h3>
                    <span class="collapse-icon">${isCollapsed ? '▶' : '▼'}</span>
                    ${provider.name || `提供商 #${index + 1}`}
                </h3>
            </div>
            <div class="config-item-content">
                <label>提供商名称:</label>
                <input type="text" class="provider-name" placeholder="例如：My OpenAI" value="${provider.name || ''}" data-index="${index}">
                <label>Base URL:</label>
                <input type="text" class="provider-baseurl" placeholder="https://api.openai.com" value="${provider.baseURL || ''}" data-index="${index}">
                <label>API Key:</label>
                <input type="password" class="provider-apikey" placeholder="API Key" value="${provider.apiKey || ''}" data-index="${index}">
                
                <div class="model-list-controls" style="margin-top:10px;">
                    <h4>可用模型 (<span class="enabled-models-count" data-provider-id="${provider.id}">${(provider.enabledModelIds || []).length}</span> 个已启用):</h4>
                    <button type="button" class="fetch-provider-models secondary-button" data-index="${index}">获取模型列表</button>
                </div>
                <div class="custom-select-wrapper provider-available-models-select" data-provider-id="${provider.id}">
                    <button type="button" class="custom-select-trigger provider-model-select-trigger">
                        管理启用模型
                    </button>
                    <div class="custom-select-dropdown provider-model-select-dropdown">
                        <input type="text" class="model-search-input provider-model-search-input" placeholder="搜索可用模型...">
                        <ul class="custom-options-list provider-model-options-list">
                            ${(provider.availableModels || []).map(model => `
                                <li data-model-id="${model.id}">
                                    <input type="checkbox" id="chk-${provider.id}-${model.id}" class="model-enable-checkbox-dropdown" 
                                           data-provider-index="${index}" data-model-id="${model.id}" 
                                           ${(provider.enabledModelIds || []).includes(model.id) ? 'checked' : ''}>
                                    <label for="chk-${provider.id}-${model.id}">${model.name || model.id}</label>
                                </li>
                            `).join('')}
                            ${(provider.availableModels || []).length === 0 ? '<li>没有可用的模型，请先获取。</li>' : ''}
                        </ul>
                    </div>
                </div>
                <label>手动添加模型ID (每行一个):</label>
                <textarea class="manual-model-ids" placeholder="gpt-3.5-turbo\ngpt-4" data-index="${index}">${(provider.manualModelIds || []).join('\n')}</textarea>
                <button type="button" class="update-manual-models secondary-button" data-index="${index}" style="margin-top:5px;">更新手动模型</button>
                <div class="config-actions" style="margin-top:15px;">
                    <button type="button" class="remove-provider danger-button" data-index="${index}">移除此提供商</button>
                </div>
            </div>
        `;
        providerListDiv.appendChild(providerItem);
    });
    populateModelSelects(); // Re-populate selects whenever providers change
}

function addProvider() {
    const newProvider = {
        id: `provider-${Date.now()}`,
        name: '',
        baseURL: '',
        apiKey: '',
        availableModels: [], // Models fetched from API
        manualModelIds: [], // Models added manually by ID
        enabledModelIds: [], // IDs of models enabled by the user from available or manual
        isCollapsed: false
    };
    providers.push(newProvider);
    saveProviders();
    renderProviders();
}

// --- 使用模型选择相关函数 (Custom Select) ---
function populateModelSelects() {
    const customSelects = [
        { list: infoModelOptionsList, valueInput: infoModelSelectValue, trigger: infoModelTrigger, currentSavedValue: modelUsageSettings.personnel },
        { list: seatingModelOptionsList, valueInput: seatingModelSelectValue, trigger: seatingModelTrigger, currentSavedValue: modelUsageSettings.seating },
        { list: seatModifyModelOptionsList, valueInput: seatModifyModelSelectValue, trigger: seatModifyModelTrigger, currentSavedValue: modelUsageSettings.seat_modification },
        { list: agentModelOptionsList, valueInput: agentModelSelectValue, trigger: agentModelTrigger, currentSavedValue: modelUsageSettings.agent } // 新增Agent模型选择
    ];

    customSelects.forEach(cs => {
        if (!cs.list) return;
        cs.list.innerHTML = ''; // Clear existing options

        // Add default "未选择" option
        const defaultLi = document.createElement('li');
        defaultLi.textContent = '--选择模型--';
        defaultLi.dataset.value = '';
        cs.list.appendChild(defaultLi);

        let foundSelected = false;
        providers.forEach(provider => {
            const uniqueEnabledModels = new Set([
                ...(provider.enabledModelIds || []),
                ...(provider.manualModelIds || [])
            ]);

            uniqueEnabledModels.forEach(modelId => {
                if (!modelId.trim()) return;
                const modelDetail = (provider.availableModels || []).find(m => m.id === modelId);
                const modelName = modelDetail ? (modelDetail.name || modelId) : modelId;
                const fullValue = `${provider.id}/${modelId}`;
                const displayText = `${provider.name || '未命名提供商'} - ${modelName}`;

                const li = document.createElement('li');
                li.textContent = displayText;
                li.dataset.value = fullValue;
                cs.list.appendChild(li);

                if (cs.currentSavedValue === fullValue) {
                    cs.trigger.textContent = displayText;
                    foundSelected = true;
                }
            });
        });
        if (!foundSelected) {
            cs.trigger.textContent = '--选择模型--';
        }
    });
}

function loadModelUsage() {
    // Values are now set directly in populateModelSelects based on modelUsageSettings
    // and also when an option is clicked.
    // We just need to ensure populateModelSelects is called and then update the active display.
    if (infoModelSelectValue) infoModelSelectValue.value = modelUsageSettings.personnel || '';
    if (seatingModelSelectValue) seatingModelSelectValue.value = modelUsageSettings.seating || '';
    if (seatModifyModelSelectValue) seatModifyModelSelectValue.value = modelUsageSettings.seat_modification || '';
    if (agentModelSelectValue) agentModelSelectValue.value = modelUsageSettings.agent || ''; // 新增Agent模型加载
    
    populateModelSelects(); // This will now also update trigger texts
    updateActiveTaskModelDisplay('personnel'); 
}

function saveModelUsage() {
    modelUsageSettings.personnel = infoModelSelectValue.value;
    modelUsageSettings.seating = seatingModelSelectValue.value;
    modelUsageSettings.seat_modification = seatModifyModelSelectValue.value;
    modelUsageSettings.agent = agentModelSelectValue.value; // 新增Agent模型保存
    saveModelUsageSettings();
    showInPageNotification('模型使用选择已保存！', 'success');
    // updateActiveTaskModelDisplay needs to know which task type's model to display.
    // Defaulting to 'personnel' or the last interacted one.
    // For simplicity, let's assume 'personnel' or rely on currentDisplayedTaskType if it's set.
    updateActiveTaskModelDisplay(currentDisplayedTaskType || 'personnel');
}

// --- 更新当前任务模型显示 ---
function updateActiveTaskModelDisplay(taskType) {
    if (!activeConfigDisplayDiv || !activeConfigStrongElement) return;

    const selectedModelValue = modelUsageSettings[taskType];
    if (selectedModelValue) {
        const [providerId, ...modelIdParts] = selectedModelValue.split('/'); // modelIdParts can be an array
        const modelId = modelIdParts.join('/'); // Rejoin if modelId itself contained '/'
        const provider = providers.find(p => p.id === providerId);
        if (provider) {
            // Try to find full model details for name
            let modelName = modelId;
            const modelDetail = (provider.availableModels || []).find(m => m.id === modelId) || 
                                (provider.manualModelIds || []).includes(modelId) ? {id: modelId, name: modelId} : null; // Basic object if manual
            if(modelDetail && modelDetail.name) modelName = modelDetail.name;

            let taskName = '';
            if (taskType === 'personnel') taskName = '信息整理';
            else if (taskType === 'seating') taskName = '座位表生成';
            else if (taskType === 'seat_modification') taskName = '座位微调';
            else if (taskType === 'agent') taskName = 'Agent驱动'; // 新增Agent任务类型
            
            activeConfigStrongElement.textContent = `${provider.name || '未命名提供商'} - ${modelName}`;
            activeConfigDisplayDiv.querySelector('p').textContent = `当前${taskName}模型: `;
            activeConfigDisplayDiv.style.display = 'block';
        } else {
            activeConfigStrongElement.textContent = '未选择或提供商丢失';
            activeConfigDisplayDiv.style.display = 'block';
        }
    } else {
        activeConfigStrongElement.textContent = '未选择';
        activeConfigDisplayDiv.style.display = 'block';
    }
}


// --- 获取具体任务的模型配置 ---
function getModelConfig(taskType) { // taskType: 'personnel', 'seating', 'seat_modification', 'agent'
    const selectedModelString = modelUsageSettings[taskType];
    if (!selectedModelString) {
        updateActiveTaskModelDisplay(taskType); // Show "未选择"
        return null;
    }

    const parts = selectedModelString.split('/');
    const providerId = parts[0];
    const modelIdFromSelection = parts.slice(1).join('/'); 
    
    const provider = providers.find(p => p.id === providerId);

    if (provider && provider.baseURL && provider.apiKey && modelIdFromSelection) {
        const apiModelId = modelIdFromSelection;

        const config = {
            baseURL: provider.baseURL,
            apiKey: provider.apiKey,
            modelId: apiModelId, 
            providerName: provider.name || providerId,
            modelName: ((provider.availableModels || []).find(m => m.id === modelIdFromSelection) || {name: modelIdFromSelection}).name
        };
        updateActiveTaskModelDisplay(taskType); 
        return config;
    }
    updateActiveTaskModelDisplay(taskType); 
    return null;
}


// --- 事件监听器 ---

// --- Sidebar Toggle Logic ---

function manageSidebarState() {
    const isSettingsOpen = settingsSidebar.classList.contains('open');
    const isAgentOpen = agentSidebar.classList.contains('open');
    const anySidebarOpen = isSettingsOpen || isAgentOpen;
    const sidebarWidth = 350; // px, should match CSS
    const buttonOffset = 20; // px

    console.log(`manageSidebarState: SettingsOpen=${isSettingsOpen}, AgentOpen=${isAgentOpen}, AnyOpen=${anySidebarOpen}`);

    if (anySidebarOpen) {
        // mainContainer.classList.add('sidebar-open-content-shift'); // No longer using class for margin
        mainContainer.style.width = `calc(100% - ${sidebarWidth}px)`;
        mainContainer.style.marginRight = `${sidebarWidth}px`; // Keep margin for spacing if needed, or remove if width alone is enough
        
        if (sidebarToggleButton) sidebarToggleButton.style.right = `${buttonOffset + sidebarWidth}px`;
        if (agentToggleButton) agentToggleButton.style.right = `${buttonOffset + sidebarWidth}px`;
        console.log(`   mainContainer width set to: calc(100% - ${sidebarWidth}px), marginRight to ${sidebarWidth}px`);
    } else {
        // mainContainer.classList.remove('sidebar-open-content-shift');
        mainContainer.style.width = '100%';
        mainContainer.style.marginRight = '0px';
        
        if (sidebarToggleButton) sidebarToggleButton.style.right = `${buttonOffset}px`;
        if (agentToggleButton) agentToggleButton.style.right = `${buttonOffset}px`;
        console.log('   mainContainer width set to: 100%, marginRight to 0px');
    }
    console.log('   sidebarToggleButton right:', sidebarToggleButton ? sidebarToggleButton.style.right : 'N/A');
    console.log('   agentToggleButton right:', agentToggleButton ? agentToggleButton.style.right : 'N/A');
}

if (sidebarToggleButton && settingsSidebar && mainContainer && agentSidebar) {
    sidebarToggleButton.addEventListener('click', (event) => {
        event.stopPropagation();
        if (settingsSidebar.classList.contains('open')) {
            settingsSidebar.classList.remove('open');
        } else {
            if (agentSidebar.classList.contains('open')) {
                agentSidebar.classList.remove('open');
            }
            settingsSidebar.classList.add('open');
        }
        manageSidebarState();
    });
}

if (agentToggleButton && agentSidebar && mainContainer && settingsSidebar) {
    agentToggleButton.addEventListener('click', (event) => {
        event.stopPropagation();
        if (agentSidebar.classList.contains('open')) {
            agentSidebar.classList.remove('open');
        } else {
            if (settingsSidebar.classList.contains('open')) {
                settingsSidebar.classList.remove('open');
            }
            agentSidebar.classList.add('open');
        }
        manageSidebarState();
    });
}

// Add event listeners for new close buttons in sidebars
const closeSidebarButtons = document.querySelectorAll('.close-sidebar-button');
closeSidebarButtons.forEach(button => {
    button.addEventListener('click', (event) => {
        event.stopPropagation();
        const sidebarToClose = button.closest('.sidebar');
        if (sidebarToClose && sidebarToClose.classList.contains('open')) {
            sidebarToClose.classList.remove('open');
            manageSidebarState();
        }
    });
});

// Removed: Click outside to close logic
// document.addEventListener('click', (event) => { ... });


// 提供商配置事件
if (addProviderButton) {
    addProviderButton.addEventListener('click', addProvider);
}

if (providerListDiv) {
    providerListDiv.addEventListener('change', (event) => {
        const target = event.target;
        const providerItemElement = target.closest('.provider-item'); 
        if (!providerItemElement) return;

        const providerIdFromElement = providerItemElement.dataset.providerId;
        const providerIndex = providers.findIndex(p => p.id === providerIdFromElement);

        if (providerIndex === undefined || providerIndex === -1) return;
        const provider = providers[providerIndex];
        if (!provider) return;

        if (target.classList.contains('provider-name')) {
            provider.name = target.value;
        } else if (target.classList.contains('provider-baseurl')) {
            provider.baseURL = target.value;
        } else if (target.classList.contains('provider-apikey')) {
            provider.apiKey = target.value;
        } else if (target.classList.contains('model-enable-checkbox-dropdown')) {
            const modelId = target.dataset.modelId;
            if (!provider.enabledModelIds) provider.enabledModelIds = [];
            
            if (target.checked) {
                if (!provider.enabledModelIds.includes(modelId)) {
                    provider.enabledModelIds.push(modelId);
                }
            } else {
                provider.enabledModelIds = provider.enabledModelIds.filter(id => id !== modelId);
            }
            const countSpan = providerItemElement.querySelector(`.enabled-models-count[data-provider-id="${provider.id}"]`);
            if (countSpan) {
                countSpan.textContent = (provider.enabledModelIds || []).length;
            }
        }
        saveProviders();
        populateModelSelects(); 
        if (modelUsageSettings[currentDisplayedTaskType]?.startsWith(provider.id + '/')) {
            updateActiveTaskModelDisplay(currentDisplayedTaskType);
        }
    });

    providerListDiv.addEventListener('click', async (event) => {
        const target = event.target;
        const providerItem = target.closest('.provider-item');
        if (!providerItem) return;

        const providerIdFromElement = providerItem.dataset.providerId;
        const providerIndex = providers.findIndex(p => p.id === providerIdFromElement);

        if (providerIndex === -1) return;
        const provider = providers[providerIndex];
        if (!provider) return;
        
        const providerItemElement = target.closest('.provider-item');

        if (target.closest('.config-item-header')) {
            const clickedProviderId = providerItemElement.dataset.providerId;
            const clickedProviderIndex = providers.findIndex(p => p.id === clickedProviderId);
            if (clickedProviderIndex !== -1) {
                providers[clickedProviderIndex].isCollapsed = !providers[clickedProviderIndex].isCollapsed;
                saveProviders();
                renderProviders(); 
            }
        } else if (target.classList.contains('provider-model-select-trigger')) {
            const dropdownWrapper = providerItemElement.querySelector('.provider-available-models-select');
            if (dropdownWrapper) {
                const currentlyOpen = dropdownWrapper.classList.contains('open');
                document.querySelectorAll('.provider-available-models-select.open').forEach(openDropdown => {
                    if (openDropdown !== dropdownWrapper) {
                        openDropdown.classList.remove('open');
                    }
                });
                dropdownWrapper.classList.toggle('open', !currentlyOpen); 
                if (dropdownWrapper.classList.contains('open')) {
                    const searchInput = dropdownWrapper.querySelector('.provider-model-search-input');
                    if (searchInput) {
                         searchInput.value = ''; 
                         const list = dropdownWrapper.querySelector('.provider-model-options-list');
                         if (list) Array.from(list.children).forEach(li => li.style.display = '');
                         searchInput.focus();
                    }
                }
            }
        } else if (target.classList.contains('fetch-provider-models')) {
            const fetchProviderId = providerItemElement.dataset.providerId; // Use correct ID
            const fetchProviderIndex = providers.findIndex(p => p.id === fetchProviderId);
            if (fetchProviderIndex === -1) return;
            const currentProvider = providers[fetchProviderIndex]; // Use correct provider object

            if (!currentProvider.baseURL || !currentProvider.apiKey) {
                showInPageNotification('请先为此提供商填写 Base URL 和 API Key。', 'warning');
                return;
            }
            target.disabled = true;
            target.textContent = '获取中...';
            try {
                const response = await fetch(`${currentProvider.baseURL}/v1/models`, { // Use currentProvider.baseURL
                    headers: { 'Authorization': `Bearer ${currentProvider.apiKey}` } // Use currentProvider.apiKey
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`获取模型列表失败: ${response.status} ${response.statusText} - ${errorData.error?.message || '未知API错误'}`);
                }
                const data = await response.json();
                currentProvider.availableModels = (data.data || []).map(m => ({ id: m.id, name: m.name || m.id }));
                currentProvider.enabledModelIds = []; 
                saveProviders();
                renderProviders(); 
                showInPageNotification(`为 "${currentProvider.name || `提供商 #${fetchProviderIndex + 1}`}" 成功获取 ${currentProvider.availableModels.length} 个模型。请在列表中手动勾选需要启用的模型。`, 'success');
            } catch (error) {
                console.error('获取模型列表时出错:', error);
                showInPageNotification(`获取模型列表失败: ${error.message}`, 'error');
            } finally {
                target.disabled = false;
                target.textContent = '获取模型列表';
            }
        } else if (target.classList.contains('update-manual-models')) {
            const textarea = providerItem.querySelector('.manual-model-ids');
            if (textarea) {
                provider.manualModelIds = textarea.value.split('\n').map(id => id.trim()).filter(id => id);
                if(!provider.enabledModelIds) provider.enabledModelIds = [];
                provider.manualModelIds.forEach(manualId => {
                    if(!provider.enabledModelIds.includes(manualId)) provider.enabledModelIds.push(manualId);
                });
                saveProviders();
                renderProviders(); 
                showInPageNotification('手动模型ID已更新。', 'success');
            }
        } else if (target.classList.contains('remove-provider')) {
            if (confirm(`确定要移除 "${provider.name || `提供商 #${providerIndex + 1}`}" 吗？`)) {
                const removedProviderId = provider.id;
                providers.splice(providerIndex, 1);
                Object.keys(modelUsageSettings).forEach(taskType => {
                    if (modelUsageSettings[taskType] && modelUsageSettings[taskType].startsWith(removedProviderId + '/')) {
                        modelUsageSettings[taskType] = null; 
                    }
                });
                saveProviders();
                saveModelUsageSettings();
                renderProviders();
                loadModelUsage(); 
            }
        }
    });
}


// 模型使用选择事件
if (saveModelUsageButton) {
    saveModelUsageButton.addEventListener('click', saveModelUsage);
}

let currentDisplayedTaskType = 'personnel'; 


// DeepSeek 快速配置
if (quickConfigDeepseekButton) {
    quickConfigDeepseekButton.addEventListener('click', () => {
        const apiKey = deepseekApiKeyInput.value.trim();
        if (!apiKey) {
            showInPageNotification('请输入 DeepSeek API Key。', 'warning');
            return;
        }

        const deepSeekProviderId = 'provider-deepseek-quick';
        let deepseekProvider = providers.find(p => p.id === deepSeekProviderId);

        if (!deepseekProvider) {
            deepseekProvider = {
                id: deepSeekProviderId,
                name: 'DeepSeek (快速配置)',
                baseURL: 'https://api.deepseek.com',
                apiKey: apiKey,
                availableModels: [ 
                    { id: 'deepseek-chat', name: 'DeepSeek Chat' },
                    { id: 'deepseek-coder', name: 'DeepSeek Coder' } 
                ],
                manualModelIds: ['deepseek-reasoner'], 
                enabledModelIds: ['deepseek-chat', 'deepseek-reasoner'], 
                isCollapsed: false
            };
            providers.push(deepseekProvider);
        } else {
            deepseekProvider.apiKey = apiKey; 
            if(!deepseekProvider.enabledModelIds.includes('deepseek-chat')) deepseekProvider.enabledModelIds.push('deepseek-chat');
            if(!deepseekProvider.enabledModelIds.includes('deepseek-reasoner')) deepseekProvider.enabledModelIds.push('deepseek-reasoner');
            if(!deepseekProvider.manualModelIds.includes('deepseek-reasoner')) deepseekProvider.manualModelIds.push('deepseek-reasoner');
        }
        
        saveProviders();
        renderProviders();

        modelUsageSettings.personnel = `${deepSeekProviderId}/deepseek-chat`;
        modelUsageSettings.seating = `${deepSeekProviderId}/deepseek-reasoner`; 
        modelUsageSettings.seat_modification = `${deepSeekProviderId}/deepseek-chat`;
        modelUsageSettings.agent = `${deepSeekProviderId}/deepseek-reasoner`; // Agent驱动模型默认使用deepseek-reasoner 
        saveModelUsageSettings();
        loadModelUsage(); 

        showInPageNotification('DeepSeek 模型已快速配置并选定用于相关任务！', 'success');
        deepseekApiKeyInput.value = '';
    });
}


// 页面加载时初始化
renderProviders();
loadModelUsage(); 


// 发送描述给 AI
sendDescriptionButton.addEventListener('click', async () => {
    const description = personDescriptionInput.value.trim();
    const personnelTaskConfig = getModelConfig('personnel');

    if (!personnelTaskConfig) {
        showInPageNotification('请在侧边栏"使用模型选择"中为"信息整理"任务选择一个模型。', 'warning');
        return;
    }
    if (!personnelTaskConfig.baseURL || !personnelTaskConfig.modelId || !personnelTaskConfig.apiKey) {
        showInPageNotification('选择的"信息整理"模型配置不完整 (缺少Base URL, Model ID, 或 API Key)。请检查提供商配置。', 'warning');
        return;
    }

    if (!description) {
        showInPageNotification('请输入人物描述。', 'warning');
        return;
    }

    if (loadingIndicator && typeof loadingIndicator.style === 'object' && loadingIndicator.style !== null) {
        loadingIndicator.style.display = 'block';
    }
    markdownOutputDiv.innerHTML = ''; 
    sendDescriptionButton.disabled = true;

    if (personnelThinkingOutputDiv && personnelThinkingPre) {
        personnelThinkingPre.textContent = '';
        personnelThinkingOutputDiv.classList.remove('thinking-output-visible');
    }

    const systemPrompt = `
你的任务是根据用户提供的人物描述信息，更新人员信息，并只返回需要修改（新增、删除、修改）的人物信息。
当前完整人员信息表（供参考，不要直接输出）：
${personnelDataToMarkdown(personnelData)}
具体操作步骤如下：
- 仔细阅读用户提供的人物描述和当前人员信息表。
- 识别新增的人物、信息有变动的人物以及可能需要删除的人物（例如，描述中不再提及的人物，如果需要删除）。
- 只输出发生变化的人物信息，使用以下格式包裹在 <changes> 标签内：
  - 新增人物：在一行开头添加 [新增]，后跟该人物的完整 markdown 表格行（| 人物 | 性别 | 备注 |）。
  - 修改人物：在一行开头添加 [修改]，后跟该人物更新后的完整 markdown 表格行（| 人物 | 性别 | 备注 |）。
  - 删除人物：在一行开头添加 [删除]，后跟该人物的姓名。
- 如果多个人物有变化，每人一行。
- 如果没有任何变化，请在 <changes> 标签内输出"没有变化"。
**示例输出：**
<changes>
[新增]| 王五 | 男 | 新来的销售，非常积极 |
[修改]| 张三 | 男 | 性格开朗，现负责协调工作 |
[删除]李四
</changes>
请只输出 <changes> 标签内的内容，不要包含其他任何文字、解释或完整的表格。
`;

    if (conversationHistory.length === 0) {
        conversationHistory.push({ role: 'system', content: systemPrompt });
    }

    const userMessage = { role: 'user', content: `<人物描述>\n${description}\n</人物描述>` };
    conversationHistory.push(userMessage);
    let storedDescriptions = JSON.parse(localStorage.getItem('user_descriptions') || '[]');
    storedDescriptions.push(description);
    localStorage.setItem('user_descriptions', JSON.stringify(storedDescriptions));

    try {
    const response = await fetch(`${personnelTaskConfig.baseURL}/v1/chat/completions`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${personnelTaskConfig.apiKey}`
        },
        body: JSON.stringify({
            model: personnelTaskConfig.modelId, // 使用原始 modelId
            messages: conversationHistory,
            stream: true,
            temperature: 0.35
        })
    });

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: { message: '无法解析错误响应' } }));
        throw new Error(`API 请求失败: ${response.status} ${response.statusText} - ${errorData.error?.message || '未知API错误'}`);
    }

        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');
        let textBeforeChanges = ""; 
        let changesBlockStreamContent = ""; 
        let inChangesBlock = false;
        let fullResponseForHistory = ""; 
        let unprocessedLinePart = ""; // Stores incomplete line from previous chunk

        markdownOutputDiv.textContent = ''; 

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            let jsonDataForLoopDoneCheck;

            for (const line of chunk.split('\n')) { // Process each line from the raw chunk
                if (line.startsWith('data: ')) {
                    const jsonData = line.substring(6).trim();
                    jsonDataForLoopDoneCheck = jsonData;
                    if (jsonData === '[DONE]') break;

                    try {
                        const parsedData = JSON.parse(jsonData);
                        const delta = parsedData.choices[0]?.delta;
                        const reasoningContent = delta?.reasoning_content || delta?.reasoning;
                        const outputContent = delta?.content;

                        if (outputContent) {
                            fullResponseForHistory += outputContent;

                            if (!inChangesBlock) {
                                if (outputContent.includes('<changes>')) {
                                    const parts = outputContent.split('<changes>');
                                    textBeforeChanges += parts[0];
                                    changesBlockStreamContent = parts[1] || '';
                                    inChangesBlock = true;
                                    markdownOutputDiv.textContent = textBeforeChanges + "<changes>" + changesBlockStreamContent.split('</changes>')[0];
                                } else {
                                    textBeforeChanges += outputContent;
                                    markdownOutputDiv.textContent = textBeforeChanges;
                                }
                            } else {
                                changesBlockStreamContent += outputContent;
                                // Display raw stream within <changes>
                                markdownOutputDiv.textContent = textBeforeChanges + "<changes>" + changesBlockStreamContent.split('</changes>')[0];
                                
                                // Process complete lines for real-time table update
                                let currentProcessingContent = unprocessedLinePart + changesBlockStreamContent;
                                if (fullResponseForHistory.includes('</changes>')) { // If end tag seen anywhere in full history
                                    currentProcessingContent = currentProcessingContent.split('</changes>')[0];
                                }

                                const instructionLines = currentProcessingContent.split('\n');
                                unprocessedLinePart = instructionLines.pop() || ""; // Last part might be incomplete

                                for (const instructionLine of instructionLines) {
                                    if (instructionLine.trim()) {
                                        if (applySinglePersonnelChange(instructionLine.trim())) {
                                            renderPersonnelTable();
                                        }
                                    }
                                }
                                // If the stream has ended (or </changes> was in this chunk), process any remaining part
                                if (jsonData === '[DONE]' || (outputContent && outputContent.includes('</changes>'))) {
                                    if (unprocessedLinePart.trim()) {
                                        if (applySinglePersonnelChange(unprocessedLinePart.trim())) {
                                            renderPersonnelTable();
                                        }
                                        unprocessedLinePart = ""; 
                                    }
                                }
                            }
                        }

                        if (reasoningContent && personnelThinkingOutputDiv && personnelThinkingPre) {
                            personnelThinkingPre.textContent += reasoningContent;
                            if (personnelThinkingPre.textContent.trim() !== '') {
                                personnelThinkingOutputDiv.classList.add('thinking-output-visible');
                            } else {
                                personnelThinkingOutputDiv.classList.remove('thinking-output-visible');
                            }
                            personnelThinkingAutoScroll();
                        }

                    } catch (e) {
                        console.error('解析人员信息 SSE 数据块时出错:', e, '数据块:', jsonData);
                    }
                }
            }
            if (typeof jsonDataForLoopDoneCheck !== 'undefined' && jsonDataForLoopDoneCheck === '[DONE]') break;
        }
        // Final processing uses fullResponseForHistory
        const changesMatch = fullResponseForHistory.match(/<changes>([\s\S]*?)<\/changes>/i);
        if (changesMatch && changesMatch[1]) {
            const changesContent = changesMatch[1].trim();
            if (changesContent && changesContent !== '没有变化') {
                updatePersonnelTable(changesContent);
            } else if (changesContent === '没有变化') {
                console.log('AI 表示没有需要更新的人员信息。');
            } else {
                console.warn('AI 返回的变化信息为空:', fullResponse);
            }
            conversationHistory.push({ role: 'assistant', content: fullResponse });
        } else {
            if (fullResponse.includes('没有变化') || fullResponse.includes('无需更新')) {
                console.log('AI 表示没有需要更新的人员信息（未找到<changes>标签）。');
            } else {
                console.error('未能从 AI 响应中提取变化信息 (无<changes>标签): ', fullResponse);
                conversationHistory.pop(); 
                if(conversationHistory.length > 0 && conversationHistory[conversationHistory.length-1].role === 'system') {
                    conversationHistory.pop(); 
                }
            }
            if (!(fullResponse.includes('没有变化') || fullResponse.includes('无需更新'))) {
                conversationHistory.push({ role: 'assistant', content: fullResponse });
            }
        }
        renderPersonnelTable();

    } catch (error) {
        console.error('调用 API 时出错:', error);
        markdownOutputDiv.innerHTML = `<p style="color: red;">发生错误: ${error.message}</p>`;
        conversationHistory.pop();
        if(conversationHistory.length > 0 && conversationHistory[conversationHistory.length-1].role === 'system') {
            conversationHistory.pop();
        }
    } finally {
        if (loadingIndicator && typeof loadingIndicator.style === 'object' && loadingIndicator.style !== null) {
            loadingIndicator.style.display = 'none';
        }
        sendDescriptionButton.disabled = false;
        renderPersonnelTable();
        if (personnelThinkingOutputDiv && personnelThinkingPre && personnelThinkingPre.textContent.trim() === '') {
            personnelThinkingOutputDiv.classList.remove('thinking-output-visible');
        }
    }
});

// Event listener for clearing the personnel table
clearPersonnelTableButton.addEventListener('click', () => {
    personnelData = [];
    localStorage.removeItem('personnel_data');
    localStorage.removeItem('user_descriptions'); 
    conversationHistory = []; 
    renderPersonnelTable();
    showInPageNotification('人员信息表已清除。', 'info');
});

// 函数：更新人员信息表格（处理AI返回的修改）
function updatePersonnelTable(markdownDiff) {
    const changesLines = markdownDiff.split('\n').map(line => line.trim()).filter(line => line !== ''); 

    changesLines.forEach(line => {
        if (line.startsWith('[新增]')) {
            const markdownLine = line.substring('[新增]'.length).trim();
            const person = parseMarkdownTableRow(markdownLine);
            if (person && person['人物']) {
                personnelData.push(person);
            }
        } else if (line.startsWith('[修改]')) {
            const markdownLine = line.substring('[修改]'.length).trim();
            const updatedPerson = parseMarkdownTableRow(markdownLine);
            if (updatedPerson && updatedPerson['人物']) {
                const existingPersonIndex = personnelData.findIndex(p => p['人物'] === updatedPerson['人物']);
                if (existingPersonIndex !== -1) {
                    personnelData[existingPersonIndex] = updatedPerson;
                } else {
                     personnelData.push(updatedPerson); // If not found, add as new
                }
            }
        } else if (line.startsWith('[删除]')) {
            const personName = line.substring('[删除]'.length).trim();
            if (personName) {
                personnelData = personnelData.filter(p => p['人物'] !== personName);
            }
        }
    });
    renderPersonnelTable();
}

// 辅助函数：解析单行 Markdown 表格数据为对象
function parseMarkdownTableRow(markdownLine) {
    const values = markdownLine.split('|').map(v => v.trim()).filter(v => v);
    if (values.length >= 3) {
        const person = {};
        person['人物'] = values[0];
        person['性别'] = values[1];
        person['备注'] = values.slice(2).join(' | ').trim(); 
        return person;
    }
    return null; 
}

// 函数：实时应用单条人员信息变更指令
function applySinglePersonnelChange(lineInstruction) {
    let changeApplied = false;
    if (lineInstruction.startsWith('[新增]')) {
        const markdownLine = lineInstruction.substring('[新增]'.length).trim();
        const person = parseMarkdownTableRow(markdownLine);
        if (person && person['人物']) {
            // 避免重复添加（尽管在流式处理中，如果AI不重复发送指令，这可能不是必需的）
            if (!personnelData.find(p => p['人物'] === person['人物'])) {
                 personnelData.push(person);
                 changeApplied = true;
            }
        }
    } else if (lineInstruction.startsWith('[修改]')) {
        const markdownLine = lineInstruction.substring('[修改]'.length).trim();
        const updatedPerson = parseMarkdownTableRow(markdownLine);
        if (updatedPerson && updatedPerson['人物']) {
            const existingPersonIndex = personnelData.findIndex(p => p['人物'] === updatedPerson['人物']);
            if (existingPersonIndex !== -1) {
                personnelData[existingPersonIndex] = updatedPerson;
                changeApplied = true;
            } else {
                 // 如果AI指示修改但人员不存在，则视为新增
                 personnelData.push(updatedPerson);
                 changeApplied = true;
            }
        }
    } else if (lineInstruction.startsWith('[删除]')) {
        const personName = lineInstruction.substring('[删除]'.length).trim();
        if (personName) {
            const initialLength = personnelData.length;
            personnelData = personnelData.filter(p => p['人物'] !== personName);
            if (personnelData.length < initialLength) {
                changeApplied = true;
            }
        }
    }
    return changeApplied;
}

// 函数：将人员数据数组转换为 Markdown 表格
function personnelDataToMarkdown(data) {
    if (!data || data.length === 0) return '';
    let markdown = '| 人物 | 性别 | 备注 |\n';
    markdown += '| --- | --- | --- |\n';
    data.forEach(person => {
        markdown += `| ${person.人物 || ''} | ${person.性别 || ''} | ${person.备注 || ''} |\n`;
    });
    return markdown;
}


// 函数：统一渲染人员表格并保存到 localStorage
function renderPersonnelTable() {
    const isCollapsed = outputSection && outputSection.classList.contains('personnel-collapsed');
    const markdownForStorage = personnelDataToMarkdown(personnelData); 

    if (isCollapsed) {
        let listHtml = '';
        if (personnelData.length > 0) {
            personnelData.forEach(person => {
                const tooltipText = `性别: ${person.性别 || '未知'}\n备注: ${person.备注 || '无'}`;
                const escapedTooltipText = tooltipText.replace(/"/g, '"').replace(/'/g, '&#39;');
                listHtml += `<div class="personnel-item" data-tooltip="${escapedTooltipText}">${person.人物 || '未知姓名'}</div>`;
            });
        } else {
            listHtml = '<div class="personnel-item-empty">无人员</div>';
        }
        markdownOutputDiv.innerHTML = listHtml;
    } else {
        let htmlTable = '<table><thead><tr><th>人物</th><th>性别</th><th>备注</th></tr></thead><tbody>';
        if (personnelData.length > 0) {
            personnelData.forEach(person => {
                const tooltipText = `性别: ${person.性别 || '未知'}\n备注: ${person.备注 || '无'}`;
                const escapedTooltipText = tooltipText.replace(/"/g, '"').replace(/'/g, '&#39;');
                htmlTable += `<tr>
                                <td data-tooltip="${escapedTooltipText}">${person.人物 || ''}</td>
                                <td>${person.性别 || ''}</td>
                                <td>${person.备注 || ''}</td>
                              </tr>`;
            });
        } else {
            htmlTable += '<tr><td colspan="3">暂无人员信息</td></tr>';
        }
        htmlTable += '</tbody></table>';
        markdownOutputDiv.innerHTML = htmlTable;
    }

    localStorage.setItem('personnel_data', JSON.stringify(personnelData));
    localStorage.setItem('current_personnel_markdown', markdownForStorage);
}


// 函数：将 Markdown 表格转换为人员数据数组
function markdownToPersonnelData(markdown) {
    const lines = markdown.split('\n').map(line => line.trim()).filter(line => line.startsWith('|') && line.endsWith('|'));
    if (lines.length < 2) return []; 
    
    const header = lines[0].split('|').map(h => h.trim()).filter(h => h);
    const dataLines = lines.slice(2);
    
    const data = dataLines.map(line => {
        const values = line.split('|').map(v => v.trim()).filter(v => v);
        const person = {};
        header.forEach((h, index) => {
            person[h] = values[index] || '';
        });
        return person;
    });
    return data;
}

// Helper function to generate empty seat table markdown
function generateEmptySeatTableMarkdown(rows, cols, deskMates) {
    if (rows < 1 || cols < 1 || deskMates < 1) {
        console.error('行数、列数和同桌数必须大于0。');
        return ""; 
    }
    if (deskMates > cols) {
        console.error('同桌数不能大于列数。');
        return "";
    }

    let markdownTable = '';
    const totalSeats = rows * cols;
    const groupSize = deskMates;
    const groupsPerRow = Math.floor(cols / groupSize);
    const remainderSeats = cols % groupSize;

    let header = '|';
    let separator = '|';
    for (let g = 0; g < groupsPerRow; g++) {
        for (let s = 0; s < groupSize; s++) {
            header += ` 座位 |`;
            separator += ` --- |`;
        }
        if (g < groupsPerRow - 1 || remainderSeats > 0) {
            header += ` 走廊 |`;
            separator += ` --- |`;
        }
    }
    if (remainderSeats > 0) {
        for (let s = 0; s < remainderSeats; s++) {
            header += ` 座位 |`;
            separator += ` --- |`;
        }
    }
    markdownTable += header + '\n';
    markdownTable += separator + '\n';

    for (let r = 0; r < rows; r++) {
        let rowMarkdown = '|';
        for (let g = 0; g < groupsPerRow; g++) {
            for (let s = 0; s < groupSize; s++) {
                const seatIndex = r * cols + g * groupSize + s + 1;
                if (seatIndex <= totalSeats) {
                    rowMarkdown += ` 座位${seatIndex} |`;
                } else {
                    rowMarkdown += `  |`;
                }
            }
            if (g < groupsPerRow - 1 || remainderSeats > 0) {
                rowMarkdown += `  |`; 
            }
        }
        if (remainderSeats > 0) {
            for (let s = 0; s < remainderSeats; s++) {
                const seatIndex = r * cols + groupsPerRow * groupSize + s + 1;
                if (seatIndex <= totalSeats) {
                    rowMarkdown += ` 座位${seatIndex} |`;
                } else {
                    rowMarkdown += `  |`;
                }
            }
        }
        markdownTable += rowMarkdown + '\n';
    }
    return markdownTable;
}

// 函数：动态生成和预览座位表 (替换旧的 generateTableButton 逻辑)
function dynamicGenerateAndPreviewTable() {
    const rows = parseInt(rowsInput.value);
    const cols = parseInt(colsInput.value);
    const deskMates = parseInt(deskMatesInput.value);

    if (rows < 1 || cols < 1 || deskMates < 1) {
        tablePreviewDiv.innerHTML = '<p style="color: #aaa;">请输入有效的行数、列数和同桌数。</p>';
        closeSeatModificationDialog(); // 确保在无效输入时也隐藏
        return;
    }
    if (deskMates > cols) {
        tablePreviewDiv.innerHTML = '<p style="color: red;">同桌数不能大于列数。</p>';
        closeSeatModificationDialog(); // 确保在无效输入时也隐藏
        return;
    }

    const markdownTable = generateEmptySeatTableMarkdown(rows, cols, deskMates);
    if (!markdownTable) {
        tablePreviewDiv.innerHTML = '<p style="color: red;">无法生成座位表预览。</p>';
        closeSeatModificationDialog();
        return;
    }

    tablePreviewDiv.innerHTML = marked.parse(markdownTable);
    localStorage.setItem('seat_table_markdown', markdownTable); 
    localStorage.setItem('original_seat_format_markdown', markdownTable); 
    localStorage.removeItem('arranged_seat_table_markdown'); 

    closeSeatModificationDialog(); // 使用新的函数来隐藏细微调整部分及其按钮
    if (seatModificationInput) seatModificationInput.value = ''; 
    if (seatModificationOutput) { 
        seatModificationOutput.innerHTML = '';
        seatModificationOutput.style.display = 'none';
    }
    seatModificationConversationHistory = []; 
}

// 为行数、列数、同桌数输入框添加事件监听器
rowsInput.addEventListener('input', dynamicGenerateAndPreviewTable);
colsInput.addEventListener('input', dynamicGenerateAndPreviewTable);
deskMatesInput.addEventListener('input', dynamicGenerateAndPreviewTable);

// 页面加载时也尝试生成一次，以防有默认值
document.addEventListener('DOMContentLoaded', () => {
    dynamicGenerateAndPreviewTable(); 
    closeSeatModificationDialog(); 
    
    // Function to sync heights of personnel info sections with table generator section
    function syncSectionHeights() {
        const tableGeneratorSection = document.querySelector('.table-generator-section');
        // const inputSec = document.querySelector('.input-section');  // 不再需要同步 input-section
        const outputSecElement = document.querySelector('.output-section');
        
        if (!tableGeneratorSection) return;
        const targetHeight = tableGeneratorSection.offsetHeight;

        // if (inputSec) inputSec.style.minHeight = `${targetHeight}px`; // 移除对 input-section 高度的设置
        
        if (outputSecElement) { // outputSectionElement is the .output-section div
            // Always set its height to match tableGeneratorSection
            outputSecElement.style.height = `${targetHeight}px`;
            // If it's collapsed, its internal wrapper might need specific handling if desired
            // but for now, just ensuring the main output-section matches height.
        }
    }

    setTimeout(syncSectionHeights, 150);
    window.addEventListener('resize', () => setTimeout(syncSectionHeights, 50));
    if (document.readyState === 'complete') {
        setTimeout(syncSectionHeights, 500);
    } else {
        window.addEventListener('load', () => setTimeout(syncSectionHeights, 200));
    }
    if (togglePersonnelListButton) {
        togglePersonnelListButton.addEventListener('click', () => setTimeout(syncSectionHeights, 50));
    }
    const tableGenSectionForObserver = document.querySelector('.table-generator-section');
    if (tableGenSectionForObserver) {
        const observer = new MutationObserver(syncSectionHeights);
        observer.observe(tableGenSectionForObserver, { childList: true, subtree: true, attributes: true, characterData: true });
    }
});


// AI 智能编排座位
const aiArrangeButton = document.getElementById('ai-arrange-button'); // 确保这是正确的按钮ID
const arrangementRemarksInput = document.getElementById('arrangement-remarks');

// Thinking output elements
const aiThinkingOutputDiv = document.getElementById('ai-thinking-output'); 
const aiThinkingPre = aiThinkingOutputDiv ? aiThinkingOutputDiv.querySelector('pre') : null;

const personnelThinkingOutputDiv = document.querySelector('.personnel-thinking-output');
const personnelThinkingPre = personnelThinkingOutputDiv ? personnelThinkingOutputDiv.querySelector('pre') : null;

const seatModifyThinkingOutputDiv = document.querySelector('.seat-modify-thinking-output');
const seatModifyThinkingPre = seatModifyThinkingOutputDiv ? seatModifyThinkingOutputDiv.querySelector('pre') : null;

// Agent Thinking Output Elements - No longer a separate div, thinking will be part of the message
// const agentThinkingOutputDiv = document.getElementById('agent-thinking-output'); // Removed
// const agentThinkingPre = agentThinkingOutputDiv ? agentThinkingOutputDiv.querySelector('pre') : null; // Removed


// AI 智能编排座位
aiArrangeButton.addEventListener('click', async () => {
    const remarks = arrangementRemarksInput.value.trim();
    const personnelTable = personnelDataToMarkdown(personnelData); 
    
    const currentRows = parseInt(rowsInput.value);
    const currentCol = parseInt(colsInput.value);
    const currentDeskMates = parseInt(deskMatesInput.value);

    if (currentRows < 1 || currentCol < 1 || currentDeskMates < 1) {
        showInPageNotification('AI编排前，请确保行数、列数和同桌数均大于0。', 'warning');
        return;
    }
    if (currentDeskMates > currentCol) {
        showInPageNotification('AI编排前，请确保同桌数不大于列数。', 'warning');
        return;
    }

    const currentEmptyTableMarkdown = generateEmptySeatTableMarkdown(currentRows, currentCol, currentDeskMates);
    if (!currentEmptyTableMarkdown) {
        showInPageNotification('无法生成座位表结构，请检查行列及同桌数设置。', 'error');
        return;
    }
    localStorage.setItem('original_seat_format_markdown', currentEmptyTableMarkdown);
    const seatTableFormat = currentEmptyTableMarkdown; 

    const seatingTaskConfig = getModelConfig('seating');

    if (!seatingTaskConfig) {
        showInPageNotification('请在侧边栏"使用模型选择"中为"座位表生成"任务选择一个模型。', 'warning');
        return;
    }
    if (!seatingTaskConfig.baseURL || !seatingTaskConfig.modelId || !seatingTaskConfig.apiKey) {
        showInPageNotification('选择的"座位表生成"模型配置不完整。请检查提供商配置。', 'warning');
        return;
    }

    if (!personnelTable || personnelTable.trim() === '') {
        showInPageNotification('请先生成人员信息表。', 'warning');
        return;
    }

    if (!seatTableFormat || seatTableFormat.trim() === '') { 
        showInPageNotification('座位表格式为空，请先生成或检查设置。', 'warning');
        return;
    }

    if (aiThinkingOutputDiv && aiThinkingPre) {
        aiThinkingPre.textContent = '';
        aiThinkingOutputDiv.classList.remove('thinking-output-visible');
    }
    
    if (tablePreviewDiv.innerHTML.trim() === '' || tablePreviewDiv.textContent.includes("请输入有效") || tablePreviewDiv.textContent.includes("无法生成")) {
        dynamicGenerateAndPreviewTable(); 
        if (tablePreviewDiv.innerHTML.trim() === '' || tablePreviewDiv.textContent.includes("请输入有效") || tablePreviewDiv.textContent.includes("无法生成")) {
             showInPageNotification('AI编排前，请确保行数、列数和同桌数设置有效。', 'warning');
             return;
        }
    }
    let seatTableFormatToUse = localStorage.getItem('original_seat_format_markdown');
    if (!seatTableFormatToUse) {
        dynamicGenerateAndPreviewTable();
        seatTableFormatToUse = localStorage.getItem('original_seat_format_markdown');
        if (!seatTableFormatToUse) {
            showInPageNotification('无法获取座位表格式，请检查行列及同桌数设置。', 'error');
            aiArrangeButton.disabled = false; 
            return;
        }
    }


    aiArrangeButton.disabled = true;

    const systemPrompt = `
你的任务是根据提供的人物表和备注内容，为人物编排教室的座位，并按照座位表格式输出编排好的座位信息。
以下是参与座位编排的人物信息：
<人物表>
${personnelTable}
</人物表>
编排座位时需要考虑的备注信息如下：
<备注>
${remarks}
</备注>
在编排座位时，请遵循以下原则：
- 保持编排合理，表格靠上的是前排，挨在一起的是同桌。
- 要综合考虑人物表和备注的内容来安排座位。
- 务必确保人员信息表中的所有人物都被编排到座位上，并且不存在重复和遗漏。每个人只能被安排一次。
- 如果备注中有特定的座位要求，请优先满足这些要求。
以下是座位表格式，你需要将表格中 "座位一", "座位二" 等占位符替换为人物表中的人物名称，或者如果该座位无人则替换为 "空座位"。
<座位表格式>
${seatTableFormatToUse}
</座位表格式>
输出要求：
1.  请在 <编排好的座位表> 标签内输出修改后的完整 Markdown 表格（包括表头和分隔行），你严格按照上述的座位表格式输出。
2.  表格单元格内只允许填写人物的姓名或者 "空座位" 这两个词。绝对不能包含任何其他文字、解释、括号、标注（例如 "(未被编排)"）或任何非人名/非"空座位"的内容。
3.  确保每个人只被安排到一个座位，不出现重复安排。
4.  如果有人物因座位不足而未能安排，请不要在表格内标注。而是在 <编排好的座位表> 标签结束后，另起新的一行，使用以下确切格式列出所有未安排的人员："未安排人员：[姓名1], [姓名2], ..."。如果所有人都已安排，则不要输出此行。
5.  除了 Markdown 表格和可选的未安排人员列表外，不要输出任何其他解释性文字或标签。
请严格按照上述要求输出。
`;

    try {
        const response = await fetch(`${seatingTaskConfig.baseURL}/v1/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${seatingTaskConfig.apiKey}`
            },
            body: JSON.stringify({
                model: seatingTaskConfig.modelId, 
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: '请根据我提供的信息开始编排座位。' }
                ],
                stream: true
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: { message: '无法解析错误响应' } }));
            throw new Error(`API 请求失败: ${response.status} ${response.statusText} - ${errorData.error?.message || '未知API错误'}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');
        let accumulatedContent = '';
        let thinkingContent = '';
        
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const jsonData = line.substring(6).trim();
                    if (jsonData === '[DONE]') break; 
                    try {
                        const parsedData = JSON.parse(jsonData);
                        const delta = parsedData.choices[0]?.delta;
                        const reasoningContent = delta?.reasoning_content || delta?.reasoning; 
                        const outputContent = delta?.content;
                        
                        if (reasoningContent && aiThinkingOutputDiv && aiThinkingPre) {
                            thinkingContent += reasoningContent;
                            aiThinkingPre.textContent = thinkingContent;
                            aiThinkingPre.scrollTop = aiThinkingPre.scrollHeight;
                            if (thinkingContent.trim() !== '') {
                                aiThinkingOutputDiv.classList.add('thinking-output-visible');
                            } else {
                                aiThinkingOutputDiv.classList.remove('thinking-output-visible');
                            }
                        }
                        
                        if (outputContent) {
                            accumulatedContent += outputContent; 
                            const tableStartTag = "<编排好的座位表>";
                            const tableEndTag = "</编排好的座位表>";
                            let currentTableSegment = "";
                            if (accumulatedContent.includes(tableStartTag)) {
                                let startIndex = accumulatedContent.indexOf(tableStartTag) + tableStartTag.length;
                                let endIndex = accumulatedContent.indexOf(tableEndTag);
                                currentTableSegment = endIndex === -1 ? accumulatedContent.substring(startIndex) : accumulatedContent.substring(startIndex, endIndex);
                                
                                if (currentTableSegment.trim() && currentTableSegment.includes("|")) {
                                    tablePreviewDiv.innerHTML = marked.parse(currentTableSegment);
                                    applyGenderColoring(); 
                                    displayOriginalSeatNumbers(); 
                                }
                            }
                        }
                    } catch (e) {
                        console.error('解析 SSE 数据块时出错:', e, '数据块:', jsonData);
                    }
                }
            }
            if (typeof jsonData !== 'undefined' && jsonData === '[DONE]') break;
        }

        const tableStartTag = "<编排好的座位表>";
        const tableEndTag = "</编排好的座位表>";
        let finalTableMarkdown = "";
        const startIndex = accumulatedContent.indexOf(tableStartTag);
        const endIndex = accumulatedContent.indexOf(tableEndTag, startIndex);

        if (startIndex !== -1 && endIndex !== -1) {
            finalTableMarkdown = accumulatedContent.substring(startIndex + tableStartTag.length, endIndex).trim();
        } else if (startIndex !== -1) { 
            finalTableMarkdown = accumulatedContent.substring(startIndex + tableStartTag.length).trim();
        }
        if (!finalTableMarkdown) {
            const tableMatchRegex = accumulatedContent.match(/(\|.*\|[\s]*)+/);
            if (tableMatchRegex) {
                finalTableMarkdown = tableMatchRegex[0].trim();
            }
        }

        if (finalTableMarkdown) {
            tablePreviewDiv.innerHTML = marked.parse(finalTableMarkdown);
            applyGenderColoring();
            displayOriginalSeatNumbers();
            localStorage.setItem('arranged_seat_table_markdown', finalTableMarkdown);
            if (aiThinkingOutputDiv && (!thinkingContent || thinkingContent.trim() === '')) {
                aiThinkingOutputDiv.classList.remove('thinking-output-visible');
            }
            openSeatModificationDialog();
        } else {
            tablePreviewDiv.innerHTML = '<p>AI 未能按预期格式返回编排好的座位表。</p>';
            if (aiThinkingOutputDiv && thinkingContent && thinkingContent.trim() !== '') {
                aiThinkingOutputDiv.classList.add('thinking-output-visible');
            }
        }

    } catch (error) {
        console.error('调用 API 进行座位编排时出错:', error);
        tablePreviewDiv.innerHTML = `<p style="color: red;">座位编排失败: ${error.message}</p>`;
        if (aiThinkingOutputDiv && aiThinkingPre) {
            aiThinkingPre.textContent += `\n\n错误: ${error.message}`;
            aiThinkingOutputDiv.classList.add('thinking-output-visible'); 
        }
    } finally {
        aiArrangeButton.disabled = false;
        if (aiThinkingOutputDiv && aiThinkingPre && aiThinkingPre.textContent.trim() === '') {
            aiThinkingOutputDiv.classList.remove('thinking-output-visible');
        }
    }
});

// 应用性别着色
function applyGenderColoring() {
    if (!personnelData || personnelData.length === 0) return;
    const tableElement = tablePreviewDiv.querySelector('table');
    if (!tableElement) return;

    const genderMap = {};
    personnelData.forEach(person => {
        if (person['人物'] && person['性别']) {
            genderMap[person['人物']] = person['性别'];
        }
    });

    const cells = tableElement.querySelectorAll('td');
    cells.forEach(cell => {
        cell.style.backgroundColor = ''; 
        const name = cell.textContent.trim();
        const nameWithoutStatus = name.replace(/\s*（未被编排）$/, '').trim();

        if (genderMap[nameWithoutStatus]) {
            if (genderMap[nameWithoutStatus].includes('男')) cell.style.backgroundColor = '#e6f3ff';
            else if (genderMap[nameWithoutStatus].includes('女')) cell.style.backgroundColor = '#ffe6f2';
        } else if (genderMap[name]) { 
             if (genderMap[name].includes('男')) cell.style.backgroundColor = '#e6f3ff';
             else if (genderMap[name].includes('女')) cell.style.backgroundColor = '#ffe6f2';
        }
    });
}

// Task 4: Display original seat numbers as background
function displayOriginalSeatNumbers() {
    const tableElement = tablePreviewDiv.querySelector('table');
    if (!tableElement) return;

    tableElement.querySelectorAll('.original-seat-number-bg').forEach(span => span.remove());

    const originalSeatFormatMarkdown = localStorage.getItem('original_seat_format_markdown');
    if (!originalSeatFormatMarkdown) { 
        console.warn("displayOriginalSeatNumbers: original_seat_format_markdown not found in localStorage.");
        return;
    }
    
    const originalFormatArray = markdownTableToArray(originalSeatFormatMarkdown);
    
    const tbody = tableElement.querySelector('tbody');
    if (!tbody) return;
    const dataRows = Array.from(tbody.rows); 

    dataRows.forEach((htmlRow, rowIndex) => {
        Array.from(htmlRow.cells).forEach((cell, cellIndex) => {
            const originalRowIndexInArray = rowIndex + 2; 

            if (originalFormatArray[originalRowIndexInArray] && originalFormatArray[originalRowIndexInArray][cellIndex] !== undefined) {
                const originalSeatPlaceholder = originalFormatArray[originalRowIndexInArray][cellIndex].trim();
                const currentCellContent = cell.textContent.trim();

                if (originalSeatPlaceholder && 
                    !originalSeatPlaceholder.toLowerCase().includes('走廊') && 
                    originalSeatPlaceholder.trim() !== '' &&
                    currentCellContent && 
                    currentCellContent.toLowerCase() !== '空座位' &&
                    currentCellContent !== originalSeatPlaceholder &&
                    !currentCellContent.toLowerCase().includes('走廊')) {
                    
                    const seatNumberMatch = originalSeatPlaceholder.match(/\d+/); 
                    if (seatNumberMatch) {
                        const originalNumber = seatNumberMatch[0];
                        const bgNumberSpan = document.createElement('span');
                        bgNumberSpan.classList.add('original-seat-number-bg');
                        bgNumberSpan.textContent = originalNumber;
                        if (getComputedStyle(cell).position === 'static') {
                            cell.style.position = 'relative';
                        }
                        cell.appendChild(bgNumberSpan);
                    }
                }
            }
        });
    });
}


// Event listener for importing seat table from markdown
if (importSeatTableButton) {
    importSeatTableButton.addEventListener('click', () => {
        const markdown = importSeatTableMarkdownTextarea.value.trim();
        if (!markdown) {
            showInPageNotification('请粘贴要导入的座位表Markdown。', 'info');
            return;
        }

        const lines = markdown.split('\n');
        if (lines.length < 2 || !lines[0].includes('|') || !lines[1].includes('---')) {
            showInPageNotification('Markdown格式似乎不正确，至少需要包含表头和分隔行。', 'warning');
            return;
        }

        tablePreviewDiv.innerHTML = marked.parse(markdown);
        localStorage.setItem('arranged_seat_table_markdown', markdown); 
        localStorage.setItem('original_seat_format_markdown', markdown); 

        const { rows, cols, deskMates } = parseImportedTableStructure(markdown);
        if (rows && cols && deskMates) {
            rowsInput.value = rows;
            colsInput.value = cols;
            deskMatesInput.value = deskMates;
            showInPageNotification(`座位表已成功导入并显示。检测到 ${rows} 行, ${cols} 列, ${deskMates} 同桌。`, 'success');
        } else {
            showInPageNotification('座位表已成功导入并显示。未能自动识别行列同桌数，请手动检查。', 'info');
        }
        
        importSeatTableMarkdownTextarea.value = ''; 

        applyGenderColoring(); 
        displayOriginalSeatNumbers(); 
        openSeatModificationDialog();
    });
}

// 函数：尝试从导入的Markdown表格解析结构
function parseImportedTableStructure(markdown) {
    const lines = markdown.trim().split('\n');
    if (lines.length < 3) return {}; // 至少需要表头、分隔符、数据行

    const headerLine = lines[0].trim();
    const dataLines = lines.slice(2).filter(line => line.trim().startsWith('|') && line.trim().endsWith('|'));
    
    if (dataLines.length === 0) return {};

    const numRows = dataLines.length;
    let numCols = 0; // 实际座位列数
    let deskMates = 1; // 默认同桌数为1

    // 解析表头以确定列数和同桌数
    const headerCells = headerLine.slice(1, -1).split('|').map(cell => cell.trim().toLowerCase());
    
    let currentGroup = [];
    const deskMateGroups = [];

    for (const cell of headerCells) {
        if (cell.includes('座位') && cell.trim() !== '') {
            numCols++; // 只计算包含“座位”的列为有效座位列
            currentGroup.push(cell);
        } else if (cell.includes('走廊') || cell.trim() === '') {
            if (currentGroup.length > 0) {
                deskMateGroups.push(currentGroup.length);
            }
            currentGroup = []; // 遇到走廊或空单元格，重置当前组
        } else { // 其他非空非走廊的单元格也视为座位列的一部分
            numCols++;
            currentGroup.push(cell);
        }
    }
    if (currentGroup.length > 0) { // 处理最后一组
        deskMateGroups.push(currentGroup.length);
    }

    if (deskMateGroups.length > 0) {
        // 取最常见的组大小作为同桌数
        const groupCounts = {};
        let maxCount = 0;
        deskMateGroups.forEach(groupSize => {
            groupCounts[groupSize] = (groupCounts[groupSize] || 0) + 1;
            if (groupCounts[groupSize] > maxCount) {
                maxCount = groupCounts[groupSize];
                deskMates = groupSize;
            }
        });
    } else if (numCols > 0 && numRows > 0) { // 如果没有明确的走廊分组，但有座位列
        deskMates = numCols; // 假设所有列都是一个大组（这种情况可能不常见）
    }


    // 如果通过表头无法有效确定列数，则尝试通过数据行确定（作为后备）
    if (numCols === 0 && dataLines.length > 0) {
        const firstDataRowCells = dataLines[0].slice(1, -1).split('|');
        numCols = firstDataRowCells.filter(cell => cell.trim() !== '').length; // 计算非空数据单元格数量
        // 这种情况下，同桌数更难确定，默认为1或整个行
        deskMates = numCols > 0 ? 1 : 1; // 默认为1，除非只有一列则为1
    }
    
    // 确保 deskMates 不为0，并且不超过 numCols
    if (deskMates === 0 && numCols > 0) deskMates = 1;
    if (deskMates > numCols && numCols > 0) deskMates = numCols;


    return { rows: numRows, cols: numCols, deskMates: deskMates };
}

// Function to open/show the seat modification dialog/section
function openSeatModificationDialog() {
    if (seatModificationSection) {
        seatModificationSection.style.display = 'flex'; 
        const sendButton = document.getElementById('send-seat-modification-button'); // 获取按钮
        if (sendButton) {
            sendButton.style.display = 'inline-block'; 
        }
        if (seatModificationInput) seatModificationInput.value = ''; 
        if (seatModificationOutput) {
            seatModificationOutput.innerHTML = ''; 
            seatModificationOutput.style.display = 'none';
        }
        seatModificationConversationHistory = []; 
    }
}

// Function to hide the seat modification dialog/section and button
function closeSeatModificationDialog() {
    if (seatModificationSection) {
        seatModificationSection.style.display = 'none'; 
    }
    const sendButton = document.getElementById('send-seat-modification-button'); // 获取按钮
    if (sendButton) {
        sendButton.style.display = 'none'; 
    }
}

// Event listener for sending seat modification instruction
if (sendSeatModificationButton) {
    sendSeatModificationButton.addEventListener('click', async () => {
        const modificationInstruction = seatModificationInput.value.trim();
        if (!modificationInstruction) {
            showInPageNotification('请输入修改指令。', 'warning');
            return;
        }

        const currentPersonnelTable = personnelDataToMarkdown(personnelData);
        let currentSeatTable = localStorage.getItem('arranged_seat_table_markdown');
        const originalSeatFormat = localStorage.getItem('original_seat_format_markdown') || "";

        if (!currentSeatTable || currentSeatTable.trim() === "") {
            currentSeatTable = originalSeatFormat;
            if (tablePreviewDiv.innerHTML.trim() === "" && originalSeatFormat) {
                 tablePreviewDiv.innerHTML = marked.parse(originalSeatFormat);
            }
        }
        
        let seatMappingInfo = "原始座位与当前内容的对应关系如下 (用于帮助您理解当前占用情况):\n";
        const originalFormatArrayForMapping = markdownTableToArray(originalSeatFormat);
        const currentSeatTableArrayForMapping = markdownTableToArray(currentSeatTable);

        if (originalFormatArrayForMapping.length > 0 && currentSeatTableArrayForMapping.length > 0 && originalFormatArrayForMapping.length === currentSeatTableArrayForMapping.length) {
            for (let r = 0; r < originalFormatArrayForMapping.length; r++) {
                if (r === 0 || originalFormatArrayForMapping[r].some(cell => cell.includes('---'))) continue;
                for (let c = 0; c < originalFormatArrayForMapping[r].length; c++) {
                    const originalSeatPlaceholder = originalFormatArrayForMapping[r][c];
                    const currentSeatContent = currentSeatTableArrayForMapping[r] ? (currentSeatTableArrayForMapping[r][c] || '未知') : '未知';
                    if (originalSeatPlaceholder && !originalSeatPlaceholder.trim().toLowerCase().includes('走廊') && originalSeatPlaceholder.trim() !== '') { 
                        seatMappingInfo += `- ${originalSeatPlaceholder.trim()}: 当前是 "${currentSeatContent.trim()}"\n`;
                    }
                }
            }
        } else {
            seatMappingInfo = "无法生成详细的座位映射信息，请主要参考下方提供的<当前座位表>。\n";
        }


        const seatModificationTaskConfig = getModelConfig('seat_modification');
        if (!seatModificationTaskConfig) {
            showInPageNotification('请在侧边栏"使用模型选择"中为"座位微调"任务选择一个模型。', 'warning');
            return;
        }
        if (!seatModificationTaskConfig.baseURL || !seatModificationTaskConfig.modelId || !seatModificationTaskConfig.apiKey) {
            showInPageNotification('选择的"座位微调"模型配置不完整。请检查提供商配置。', 'warning');
            return;
        }

        if (seatModificationLoading) seatModificationLoading.style.display = 'block';
        if (seatModificationOutput) {
            seatModificationOutput.innerHTML = ''; 
            seatModificationOutput.style.display = 'none'; 
        }
        if (seatModifyThinkingOutputDiv && seatModifyThinkingPre) {
            seatModifyThinkingPre.textContent = '';
            seatModifyThinkingOutputDiv.classList.remove('thinking-output-visible');
        }
        sendSeatModificationButton.disabled = true;

        const systemPromptForSeatModification = `
你的任务是根据用户提供的人物信息表、当前的座位表以及用户的修改指令，对座位表进行细微调整。
当前人员信息表（供参考，你可以自行判断是否与修改指令相关）：
<人物表>
${currentPersonnelTable}
</人物表>
这是供您参考的原始空座位表结构，其中包含所有可用的座位占位符。您在指令中引用座位时，可以使用这些占位符（例如 "座位1", "座位7"）：
<原始座位表格式>
${originalSeatFormat}
</原始座位表格式>
当前的座位表如下，请基于此表进行修改：
<当前座位表>
${currentSeatTable}
</当前座位表>
为了帮助您准确理解当前每个原始座位上的人员情况，以下是原始座位占位符与当前实际内容的对应列表：
${seatMappingInfo}
请您在处理用户指令时，务必参考此对应列表来确定用户所说的"座位X"当前具体是哪位人员或什么状态。
请根据用户的最新修改指令，对上方提供的<当前座位表>进行调整。这是您需要操作的唯一真实座位状态。
您不需要输出完整的座位表，只需要输出具体的修改操作。**为了确保系统能正确解析您的操作，请严格按照以下格式描述您的修改，每项修改占一行，并全部包裹在 <seat_changes> 和 </seat_changes> 标签内：**
1. 交换座位: \`[SWAP] 座位X <-> 座位Y\` (例如: \`[SWAP] 座位3 <-> 座位7\` 表示交换座位3和座位7上的人)
2. 移动人物到空位: \`[MOVE] 人物A TO 座位X\` (例如: \`[MOVE] 李四 TO 座位10\` 表示将李四移动到座位10，原座位变为空)
3. 清空座位: \`[EMPTY] 座位X\` (例如: \`[EMPTY] 座位5\` 表示将座位5清空)
4. 将人物填入空位: \`[FILL] 座位X WITH 人物A\` (如果人物A当前不在任何座位上, 例如: \`[FILL] 座位2 WITH 王五\`)
**重要：**
- 如果有多项修改，请确保每项修改都遵循上述格式并单独占一行。
- 如果无法完全按用户指令修改（例如，目标座位已有人且不是交换指令），请在 <seat_changes> 标签内用纯文本清晰地说明原因或提出替代方案，不要尝试使用上述操作格式进行无效操作。
- 如果用户的指令没有意义或无法操作，请在 <seat_changes> 标签内直接说明。
- **任何不符合上述格式的输出都可能导致修改无法被系统正确应用。**
请将你的修改操作包裹在 <seat_changes> 和 </seat_changes> 标签内。
例如：
<seat_changes>
[SWAP] 座位1 <-> 座位4
[MOVE] 张三 TO 座位8
</seat_changes>
`;
        
        seatModificationConversationHistory.push({ role: 'user', content: modificationInstruction });
        const messagesForAPI = [
            { role: 'system', content: systemPromptForSeatModification },
            ...seatModificationConversationHistory 
        ];

        try {
            const response = await fetch(`${seatModificationTaskConfig.baseURL}/v1/chat/completions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${seatModificationTaskConfig.apiKey}`
                },
                body: JSON.stringify({
                    model: seatModificationTaskConfig.modelId, 
                    messages: messagesForAPI,
                    stream: true 
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: { message: '无法解析错误响应' } }));
                throw new Error(`API 请求失败: ${response.status} ${response.statusText} - ${errorData.error?.message || '未知API错误'}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let accumulatedResponse = "";
            let thinkingPart = ""; 
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonData = line.substring(6).trim();
                        if (jsonData === '[DONE]') break;
                        try {
                            const parsedData = JSON.parse(jsonData);
                            const delta = parsedData.choices[0]?.delta;
                            const reasoningContent = delta?.reasoning_content || delta?.reasoning; 
                            const outputContent = delta?.content;

                            if (reasoningContent && seatModifyThinkingOutputDiv && seatModifyThinkingPre) {
                                thinkingPart += reasoningContent;
                                seatModifyThinkingPre.textContent = thinkingPart;
                                if (thinkingPart.trim() !== '') {
                                    seatModifyThinkingOutputDiv.classList.add('thinking-output-visible');
                                } else {
                                    seatModifyThinkingOutputDiv.classList.remove('thinking-output-visible');
                                }
                            }
                            if (outputContent) accumulatedResponse += outputContent; 
                        } catch (e) { console.error('解析修改座位SSE数据块时出错:', e, '数据块:', jsonData); }
                    }
                }
                 if (typeof jsonData !== 'undefined' && jsonData === '[DONE]') break;
            }
            
            seatModificationConversationHistory.push({ role: 'assistant', content: accumulatedResponse }); 
            
            const originalFormatForProcessing = localStorage.getItem('original_seat_format_markdown') || "";
            let currentArrangedTableForProcessing = localStorage.getItem('arranged_seat_table_markdown');
            if (!currentArrangedTableForProcessing || currentArrangedTableForProcessing.trim() === "") {
                currentArrangedTableForProcessing = originalFormatForProcessing;
            }

            const { newSeatTableMarkdown, changesSummary } = processSeatChanges(accumulatedResponse, currentArrangedTableForProcessing, originalFormatForProcessing);

            if (newSeatTableMarkdown) {
                tablePreviewDiv.innerHTML = marked.parse(newSeatTableMarkdown); 
                localStorage.setItem('arranged_seat_table_markdown', newSeatTableMarkdown); 
                applyGenderColoring();
                displayOriginalSeatNumbers(); 
                if (seatModificationOutput) {
                    seatModificationOutput.innerHTML = `<strong>已应用修改:</strong><br><pre>${changesSummary}</pre>`;
                }
            } else if (changesSummary) { 
                 if (seatModificationOutput) {
                    let styledChangesSummary = '';
                    if (changesSummary) {
                        const lines = changesSummary.split('\n');
                        styledChangesSummary = lines.map(line => {
                            line = line.replace(/</g, "<").replace(/>/g, ">"); 
                            if (line.startsWith('[SWAP]')) return `<span class="seat-mod-command seat-mod-swap">${line}</span>`;
                            if (line.startsWith('[MOVE]')) return `<span class="seat-mod-command seat-mod-move">${line}</span>`;
                            if (line.startsWith('[EMPTY]')) return `<span class="seat-mod-command seat-mod-empty">${line}</span>`;
                            if (line.startsWith('[FILL]')) return `<span class="seat-mod-command seat-mod-fill">${line}</span>`;
                            if (line.toLowerCase().includes('[错误]') || line.toLowerCase().includes('[error]')) return `<span class="seat-mod-error">${line}</span>`;
                            if (line.toLowerCase().includes('[警告]') || line.toLowerCase().includes('[warn')) return `<span class="seat-mod-error" style="background-color: #fff3cd; color: #856404;">${line}</span>`;
                            return `<span class="seat-mod-message">${line}</span>`; 
                        }).join('<br>');
                    }

                    if (changesSummary === accumulatedResponse && thinkingPart.trim() !== "") {
                        seatModificationOutput.innerHTML = `<p class="seat-mod-message">AI 回复 (未包含有效指令):</p><pre>${styledChangesSummary.replace(/<br>/g, '\n')}</pre>`;
                    } else if (accumulatedResponse.includes("<seat_changes>")) {
                        seatModificationOutput.innerHTML = `<strong>AI 指令处理结果:</strong><br>${styledChangesSummary}`;
                        if (!newSeatTableMarkdown && changesSummary !== "AI 表示没有修改。") { 
                             seatModificationOutput.innerHTML += `<br><br><strong>原始AI回复:</strong><pre>${accumulatedResponse.replace(/</g, "<").replace(/>/g, ">")}</pre>`;
                        }
                    } else { 
                         seatModificationOutput.innerHTML = `<strong>AI 回复:</strong><br>${styledChangesSummary}`;
                    }
                }
            } else { 
                if (seatModificationOutput) {
                    if (thinkingPart.trim() === '' || !accumulatedResponse.match(/<seat_changes>\s*<\/seat_changes>/i)) {
                         seatModificationOutput.innerHTML = `<pre>${accumulatedResponse.replace(/</g, "<").replace(/>/g, ">")}</pre>`;
                    } else {
                        seatModificationOutput.innerHTML = `<p class="seat-mod-message">AI 未返回可操作的修改指令。</p>`;
                    }
                }
            }
            if(seatModificationOutput) seatModificationOutput.style.display = 'block';
            if (seatModifyThinkingOutputDiv && seatModifyThinkingPre && seatModifyThinkingPre.textContent.trim() === '') {
                seatModifyThinkingOutputDiv.classList.remove('thinking-output-visible');
            }

        } catch (error) {
            console.error('修改座位时出错:', error);
            if (seatModificationOutput) {
                seatModificationOutput.innerHTML = `<p style="color: red;">修改座位失败: ${error.message}</p>`;
                seatModificationOutput.style.display = 'block';
            }
            if (seatModifyThinkingOutputDiv && seatModifyThinkingPre) { 
                seatModifyThinkingPre.textContent += `\n\n错误: ${error.message}`;
                if (seatModifyThinkingPre.textContent.trim() !== '') {
                    seatModifyThinkingOutputDiv.classList.add('thinking-output-visible');
                }
            }
        } finally {
            if (seatModificationLoading) seatModificationLoading.style.display = 'none';
            sendSeatModificationButton.disabled = false;
            if (seatModifyThinkingOutputDiv && seatModifyThinkingPre && seatModifyThinkingPre.textContent.trim() === '') {
                seatModifyThinkingOutputDiv.classList.remove('thinking-output-visible');
            }
        }
    });
}

// Helper function to parse Markdown table to 2D array
function markdownTableToArray(markdown) {
    if (!markdown || typeof markdown !== 'string') return [];
    const rows = markdown.trim().split('\n');
    return rows.map(row => {
        const cells = row.split('|').map(cell => cell.trim());
        if (cells.length > 0 && cells[0] === '') cells.shift();
        if (cells.length > 0 && cells[cells.length - 1] === '') cells.pop();
        return cells;
    });
}

// Helper function to convert 2D array back to Markdown table
function arrayToMarkdownTable(array) {
    if (!array || array.length === 0) return "";
    return array.map(row => `| ${row.join(' | ')} |`).join('\n');
}

// Function to process AI's seat change instructions
function processSeatChanges(aiResponse, currentSeatTableMarkdown, originalSeatFormatMarkdown) {
    let newSeatTableMarkdown = null;
    let changesSummary = ""; 

    const changesMatch = aiResponse.match(/<seat_changes>([\s\S]*?)<\/seat_changes>/i);
    
    if (!changesMatch || !changesMatch[1] || changesMatch[1].trim() === "") {
        changesSummary = aiResponse.trim();
        return { newSeatTableMarkdown, changesSummary };
    }

    const changeInstructions = changesMatch[1].trim().split('\n').map(line => line.trim()).filter(line => line);
    
    if (changeInstructions.length === 0 || (changeInstructions.length === 1 && changeInstructions[0].toLowerCase() === "没有修改")) {
        changesSummary = "AI 表示没有修改。"; 
        return { newSeatTableMarkdown: currentSeatTableMarkdown, changesSummary }; 
    }

    let seatTableArray = markdownTableToArray(currentSeatTableMarkdown);
    const originalFormatArray = markdownTableToArray(originalSeatFormatMarkdown); 
    const appliedChanges = [];
    let tableWasModified = false;

    function mapPlaceholderToCoords(placeholderText, formatArray) {
        for (let r = 0; r < formatArray.length; r++) {
            if (r === 0 || formatArray[r].some(cell => cell.includes('---'))) continue;
            for (let c = 0; c < formatArray[r].length; c++) {
                if (formatArray[r][c] === placeholderText) return { r, c };
            }
        }
        return null;
    }

    function findPersonCoords(personName, currentTableArray) {
        for (let r = 0; r < currentTableArray.length; r++) {
            if (r === 0 || currentTableArray[r].some(cell => cell.includes('---'))) continue;
            for (let c = 0; c < currentTableArray[r].length; c++) {
                if (currentTableArray[r][c] === personName) return { r, c };
            }
        }
        return null;
    }

    for (const instruction of changeInstructions) {
        let match;
        if ((match = instruction.match(/^\[SWAP\]\s*(.+?)\s*<->\s*(.+)$/i))) {
            const item1Placeholder = match[1].trim(); 
            const item2Placeholder = match[2].trim(); 
            const coords1 = mapPlaceholderToCoords(item1Placeholder, originalFormatArray);
            const coords2 = mapPlaceholderToCoords(item2Placeholder, originalFormatArray);

            if (coords1 && coords2 && seatTableArray[coords1.r] && seatTableArray[coords1.c] !== undefined && seatTableArray[coords2.r] && seatTableArray[coords2.c] !== undefined) {
                const temp = seatTableArray[coords1.r][coords1.c];
                seatTableArray[coords1.r][coords1.c] = seatTableArray[coords2.r][coords2.c];
                seatTableArray[coords2.r][coords2.c] = temp;
                appliedChanges.push(`交换了 ${item1Placeholder} (新内容: ${seatTableArray[coords1.r][coords1.c]}) 和 ${item2Placeholder} (新内容: ${seatTableArray[coords2.r][coords2.c]}) 的位置。`);
                tableWasModified = true;
            } else {
                appliedChanges.push(`[错误] 交换失败: 原始座位 "${item1Placeholder}" 或 "${item2Placeholder}" 未在格式表中找到，或对应当前表格位置无效。`);
            }
        } else if ((match = instruction.match(/^\[MOVE\]\s*(.+?)\s*TO\s*(.+)$/i))) {
            const personName = match[1].trim();
            const targetSeatPlaceholder = match[2].trim(); 
            const personOldCoords = findPersonCoords(personName, seatTableArray);
            const targetCoords = mapPlaceholderToCoords(targetSeatPlaceholder, originalFormatArray);

            if (targetCoords) {
                const currentTargetContent = seatTableArray[targetCoords.r][targetCoords.c];
                if (currentTargetContent.toLowerCase() === '空座位' || currentTargetContent === targetSeatPlaceholder || currentTargetContent === personName) {
                    if (personOldCoords) seatTableArray[personOldCoords.r][personOldCoords.c] = '空座位'; 
                    seatTableArray[targetCoords.r][targetCoords.c] = personName;
                    appliedChanges.push(`将 "${personName}" 移动到 "${targetSeatPlaceholder}"。`);
                    tableWasModified = true;
                } else {
                    appliedChanges.push(`[错误] 移动 "${personName}" 失败: 目标 "${targetSeatPlaceholder}" 已被 "${currentTargetContent}" 占据。`);
                }
            } else {
                appliedChanges.push(`[错误] 移动 "${personName}" 失败: 目标座位 "${targetSeatPlaceholder}" 未在格式表中找到。`);
            }
        } else if ((match = instruction.match(/^\[EMPTY\]\s*(.+)$/i))) {
            const seatToEmptyPlaceholder = match[1].trim(); 
            const coords = mapPlaceholderToCoords(seatToEmptyPlaceholder, originalFormatArray);
            if (coords) {
                appliedChanges.push(`清空了 "${seatToEmptyPlaceholder}" (原内容: ${seatTableArray[coords.r][coords.c]})。`);
                seatTableArray[coords.r][coords.c] = '空座位'; 
                tableWasModified = true;
            } else {
                appliedChanges.push(`[错误] 清空失败: 座位 "${seatToEmptyPlaceholder}" 未在格式表中找到。`);
            }
        } else if ((match = instruction.match(/^\[FILL\]\s*(.+?)\s*WITH\s*(.+)$/i))) {
            const seatToFillPlaceholder = match[1].trim(); 
            const personName = match[2].trim();
            const targetCoords = mapPlaceholderToCoords(seatToFillPlaceholder, originalFormatArray);

            if (targetCoords) {
                const currentTargetContent = seatTableArray[targetCoords.r][targetCoords.c];
                if (currentTargetContent.toLowerCase() === '空座位' || currentTargetContent === seatToFillPlaceholder) {
                    const personAlreadySeatedCoords = findPersonCoords(personName, seatTableArray);
                    if (personAlreadySeatedCoords) {
                        appliedChanges.push(`[警告] 填入 "${personName}" 失败: 该人员已在座位 (内容: ${seatTableArray[personAlreadySeatedCoords.r][personAlreadySeatedCoords.c]}) 。请先将其移开或清空。`);
                    } else {
                        seatTableArray[targetCoords.r][targetCoords.c] = personName;
                        appliedChanges.push(`将 "${personName}" 填入 "${seatToFillPlaceholder}"。`);
                        tableWasModified = true;
                    }
                } else {
                     appliedChanges.push(`[错误] 填入 "${personName}" 失败: "${seatToFillPlaceholder}" 已被 "${currentTargetContent}" 占据。`);
                }
            } else {
                 appliedChanges.push(`[错误] 填入 "${personName}" 失败: 座位 "${seatToFillPlaceholder}" 未在格式表中找到。`);
            }
        } else {
            appliedChanges.push(instruction); 
        }
    }
    
    if (tableWasModified) newSeatTableMarkdown = arrayToMarkdownTable(seatTableArray);
    else newSeatTableMarkdown = null; 
    
    changesSummary = appliedChanges.join('\n');
    return { newSeatTableMarkdown, changesSummary };
}


// Event listener for importing personnel table from markdown
importPersonnelButton.addEventListener('click', () => {
    const markdown = importPersonnelMarkdownTextarea.value.trim();
    if (!markdown) {
        showInPageNotification('请粘贴要导入的Markdown表格。', 'info');
        return;
    }

    const importedData = markdownToPersonnelData(markdown);
    if (importedData.length > 0) {
        personnelData = importedData;
        renderPersonnelTable(); 
        showInPageNotification(`成功导入 ${importedData.length} 条人员信息。`, 'success');
        importPersonnelMarkdownTextarea.value = ''; 
    } else {
        showInPageNotification('未能解析为有效的人员信息表格，请检查Markdown格式是否正确（需要表头、分隔线和数据行）。', 'warning');
    }
});

// Event listener for copying the seat table format - 按钮已移除
// if (copyTableButton) { ... }

// Event listener for copying the arranged seat table
copyArrangedTableButton.addEventListener('click', () => {
    const arrangedMarkdownTable = localStorage.getItem('arranged_seat_table_markdown') || '';
    if (arrangedMarkdownTable) {
        navigator.clipboard.writeText(arrangedMarkdownTable).then(() => {
            showInPageNotification('编排好的座位表已复制到剪贴板！', 'success');
        }, () => {
            showInPageNotification('复制失败，请手动复制表格内容。', 'error');
        });
    } else {
        showInPageNotification('请先进行AI智能编排。', 'warning');
    }
});

// Event listener for copying the personnel info
if (copyPersonnelInfoButton) {
    copyPersonnelInfoButton.addEventListener('click', () => {
        const markdownToCopy = personnelDataToMarkdown(personnelData);
        if (markdownToCopy) {
            navigator.clipboard.writeText(markdownToCopy).then(() => {
                showInPageNotification('人员信息已复制到剪贴板！', 'success');
            }, () => {
                showInPageNotification('复制失败，请手动复制。', 'error');
            });
        } else {
            showInPageNotification('当前没有人员信息可复制。', 'info');
        }
    });
}

// Personnel List Toggle
if (togglePersonnelListButton && outputSection && contentWrapper) {
    togglePersonnelListButton.addEventListener('click', () => {
        const isNowCollapsed = outputSection.classList.toggle('personnel-collapsed');
        // contentWrapper.classList.toggle('personnel-list-collapsed', isNowCollapsed); // This class might not be needed anymore if direct width styling is used

        if (isNowCollapsed) {
            togglePersonnelListButton.innerHTML = '▶'; // Indicate it can be expanded
        } else {
            togglePersonnelListButton.innerHTML = '<'; // Indicate it can be collapsed
        }
        renderPersonnelTable(); // Re-render table for collapsed/expanded view
        // Hide/show description input based on collapsed state
        const descriptionGroup = outputSection.querySelector('.description-input-group');
        if (descriptionGroup) {
            descriptionGroup.style.display = isNowCollapsed ? 'none' : 'flex';
        }
    });
}

// --- Custom Model Select Search Functionality ---
document.addEventListener('DOMContentLoaded', () => {
    const customSelectWrappers = document.querySelectorAll('.custom-select-wrapper');

    customSelectWrappers.forEach(wrapper => {
        const trigger = wrapper.querySelector('.custom-select-trigger');
        const dropdown = wrapper.querySelector('.custom-select-dropdown');
        const searchInput = dropdown.querySelector('.model-search-input');
        const optionsList = dropdown.querySelector('.custom-options-list');
        const hiddenValueInputId = trigger.id.replace('-trigger', '-select-value'); 
        const hiddenValueInput = document.getElementById(hiddenValueInputId);

        if (!trigger || !dropdown || !searchInput || !optionsList || !hiddenValueInput) return;

        trigger.addEventListener('click', (event) => {
            event.stopPropagation();
            customSelectWrappers.forEach(otherWrapper => {
                if (otherWrapper !== wrapper) {
                    otherWrapper.classList.remove('open');
                }
            });
            wrapper.classList.toggle('open');
            if (wrapper.classList.contains('open')) {
                searchInput.focus();
                searchInput.value = '';
                Array.from(optionsList.children).forEach(li => li.classList.remove('hidden-by-search'));
            }
        });

        searchInput.addEventListener('input', () => {
            const searchTerm = searchInput.value.toLowerCase();
            Array.from(optionsList.children).forEach(li => {
                const optionText = li.textContent.toLowerCase();
                if (li.dataset.value === "") { 
                    li.classList.remove('hidden-by-search');
                } else {
                    li.classList.toggle('hidden-by-search', !optionText.includes(searchTerm));
                }
            });
        });

        optionsList.addEventListener('click', (event) => {
            if (event.target.tagName === 'LI') {
                const selectedValue = event.target.dataset.value;
                const selectedText = event.target.textContent;
                
                trigger.textContent = selectedText;
                hiddenValueInput.value = selectedValue;
                wrapper.classList.remove('open');

                let taskType = '';
                if (trigger === infoModelTrigger) taskType = 'personnel';
                else if (trigger === seatingModelTrigger) taskType = 'seating';
                else if (trigger === seatModifyModelTrigger) taskType = 'seat_modification';
                else if (trigger === agentModelTrigger) taskType = 'agent'; // 新增Agent模型选择支持
                
                if (taskType) {
                    currentDisplayedTaskType = taskType; 
                    modelUsageSettings[taskType] = selectedValue; 
                    updateActiveTaskModelDisplay(taskType);
                }
            }
        });
    });

    window.addEventListener('click', (event) => {
        customSelectWrappers.forEach(wrapper => {
            if (!wrapper.contains(event.target) && wrapper.classList.contains('open')) {
                wrapper.classList.remove('open');
            }
        });
        document.querySelectorAll('.provider-available-models-select.open').forEach(dropdown => {
            const itsTrigger = dropdown.querySelector('.provider-model-select-trigger');
            if (!dropdown.contains(event.target) && (!itsTrigger || !itsTrigger.contains(event.target))) {
                dropdown.classList.remove('open');
            }
        });
    });

    providerListDiv.addEventListener('input', (event) => {
        const target = event.target;
        if (target.classList.contains('provider-model-search-input')) {
            const searchTerm = target.value.toLowerCase();
            const dropdownWrapper = target.closest('.custom-select-dropdown'); 
            if (dropdownWrapper) {
                const list = dropdownWrapper.querySelector('.provider-model-options-list');
                if (list) {
                    Array.from(list.children).forEach(li => {
                        const modelLabel = li.querySelector('label');
                        if (modelLabel) {
                            const modelName = modelLabel.textContent.toLowerCase();
                            li.style.display = modelName.includes(searchTerm) ? '' : 'none';
                        } else if (li.textContent.toLowerCase().includes('没有可用')) { 
                            li.style.display = ''; 
                        }
                    });
                }
            }
        }
    });
});

// === Agent功能相关代码 - 新增的AI Agent统筹功能 ===

// Agent对话功能 - 发送消息到AI API
if (agentSendButton && agentChatInput && agentChatMessages) {
    agentSendButton.addEventListener('click', sendAgentMessage);
    agentChatInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendAgentMessage();
        }
    });
}

// Agent清空对话历史功能
if (agentClearButton && agentChatMessages) {
    agentClearButton.addEventListener('click', () => {
        if (confirm('确定要清空所有对话记录吗？')) {
            agentConversationHistory = [];
            agentChatMessages.innerHTML = '';
            showInPageNotification('Agent对话记录已清空。', 'info');
        }
    });
}

// Agent配置保存功能
if (agentSaveConfigButton && agentSystemPromptTextarea) {
    agentSaveConfigButton.addEventListener('click', () => {
        agentSystemPrompt = agentSystemPromptTextarea.value.trim();
        localStorage.setItem('agent_system_prompt', agentSystemPrompt);
        showInPageNotification('Agent配置已保存！', 'success');
    });
}

// 页面加载时恢复Agent配置
document.addEventListener('DOMContentLoaded', () => {
    const savedSystemPrompt = localStorage.getItem('agent_system_prompt') || '';
    agentSystemPrompt = savedSystemPrompt;
    if (agentSystemPromptTextarea) {
        agentSystemPromptTextarea.value = savedSystemPrompt;
    }
});

// Agent发送消息核心函数
async function sendAgentMessage() {
    const userMessage = agentChatInput.value.trim();
    if (!userMessage) return;

    // 获取Agent模型配置
    const agentConfig = getModelConfig('agent');
    if (!agentConfig) {
        showInPageNotification('请在侧边栏"使用模型选择"中为"Agent驱动模型"选择一个模型。', 'warning');
        return;
    }

    // 添加用户消息到界面
    addAgentMessage('user', userMessage);
    agentChatInput.value = '';
    agentSendButton.disabled = true;

    // 添加用户消息到对话历史
    agentConversationHistory.push({ role: 'user', content: userMessage });

    const aiMessageId = `agent-msg-${Date.now()}-${Math.random().toString(36).substring(2,7)}`;
    let aiMessageDiv = createAgentMessageElement('assistant', 'AI 正在思考中...', aiMessageId);
    agentChatMessages.appendChild(aiMessageDiv);
    let aiMessageContentDiv = aiMessageDiv.querySelector('.agent-message-content');
    // Ensure the thinking message is visible and scroll to it
    agentChatMessages.scrollTop = agentChatMessages.scrollHeight;


    try {
        // 构建请求消息
        const messagesForAPI = [];
        // 系统提示词 (如果已配置)
        // if (agentSystemPrompt) { messagesForAPI.push({ role: 'system', content: agentSystemPrompt }); }
        
        const recentHistory = agentConversationHistory.slice(-20); // 保留最近20条
        messagesForAPI.push(...recentHistory);

        let accumulatedAiResponse = ""; // 用于存储完整的AI回复以加入历史记录

        try {
            const response = await fetch(`${agentConfig.baseURL}/v1/chat/completions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${agentConfig.apiKey}`
                },
                body: JSON.stringify({
                    model: agentConfig.modelId,
                    messages: messagesForAPI,
                    temperature: 0.7,
                    max_tokens: 2000,
                    stream: true // 启用流式传输
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`API请求失败: ${response.status} ${response.statusText} - ${errorData.error?.message || '未知错误'}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let thinkingContent = "";

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonData = line.substring(6).trim();
                        if (jsonData === '[DONE]') break;
                        try {
                            const parsedData = JSON.parse(jsonData);
                            const delta = parsedData.choices[0]?.delta;
                            const reasoningChunk = delta?.reasoning_content || delta?.reasoning;
                            const contentChunk = delta?.content;

                            if (reasoningChunk) {
                                thinkingContent += reasoningChunk;
                                // Update the "Thinking..." message bubble with reasoning content
                                // For simplicity, we'll show reasoning in a pre tag within the message
                                if (aiMessageContentDiv.innerHTML.startsWith('AI 正在思考中...')) {
                                    aiMessageContentDiv.innerHTML = '<strong>AI 思考过程:</strong><pre style="margin-top: 5px; white-space: pre-wrap; word-wrap: break-word; max-height: 150px; overflow-y: auto; background-color: #f0f0f0; border: 1px dashed #ccc; padding: 5px; border-radius: 4px;"></pre>';
                                }
                                const preElement = aiMessageContentDiv.querySelector('pre');
                                if (preElement) {
                                    preElement.textContent = thinkingContent;
                                    preElement.scrollTop = preElement.scrollHeight; // Scroll pre if it overflows
                                }
                                agentChatMessages.scrollTop = agentChatMessages.scrollHeight;
                            }
                            if (contentChunk) {
                                // If we were showing reasoning, clear it or replace it when actual content arrives
                                if (aiMessageContentDiv.querySelector('pre')) {
                                    aiMessageContentDiv.innerHTML = ''; // Clear reasoning once content starts
                                    accumulatedAiResponse = ''; // Reset accumulated response
                                }
                                accumulatedAiResponse += contentChunk;
                                aiMessageContentDiv.innerHTML = marked.parse(accumulatedAiResponse); // Render Markdown
                                agentChatMessages.scrollTop = agentChatMessages.scrollHeight;
                            }
                        } catch (e) {
                            console.error('解析Agent SSE数据块时出错:', e, '数据块:', jsonData);
                        }
                    }
                }
                if (typeof jsonData !== 'undefined' && jsonData === '[DONE]') break;
            }
            
            // 流结束后，将完整的AI回复添加到历史记录
            if (accumulatedAiResponse) {
                 agentConversationHistory.push({ role: 'assistant', content: accumulatedAiResponse });
            } else { // 如果没有内容块，但可能有错误或空回复
                if (!aiMessageContentDiv.textContent) {
                     aiMessageContentDiv.textContent = 'AI未返回有效内容。';
                }
            }

        } catch (error) {
            console.error('Agent API调用错误:', error);
            if (aiMessageContentDiv) {
                aiMessageContentDiv.innerHTML = marked.parse(`错误: ${error.message}`);
            } else {
                addAgentMessage('assistant', `处理回复时出错: ${error.message}`);
            }
            showInPageNotification(`Agent调用失败: ${error.message}`, 'error');
        } 
        // No separate outer catch needed if all primary operations are within the inner try-catch
        // The outer try was primarily for the initial message creation which is now less prone to fail before fetch.
    } finally { 
        agentSendButton.disabled = false;
        // If thinking was shown and not replaced by content, ensure it's cleared or finalized.
        // This logic is now handled by replacing thinking content with actual content.
        if(agentChatMessages) agentChatMessages.scrollTop = agentChatMessages.scrollHeight;
    }
}


// 创建Agent消息元素的辅助函数
function createAgentMessageElement(role, content, id) {
    const messageDiv = document.createElement('div');
    if (id) messageDiv.id = id;
    messageDiv.className = `agent-message ${role === 'user' ? 'user-message' : 'agent-message-assistant'}`;
    
    const roleLabel = role === 'user' ? '用户' : 'Agent';
    const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    
    const headerDiv = document.createElement('div');
    headerDiv.className = 'agent-message-header';
    headerDiv.innerHTML = `<strong>${roleLabel}</strong> <span class="agent-message-time">${timestamp}</span>`;

    const contentDiv = document.createElement('div');
    contentDiv.className = 'agent-message-content';
    // If content is "AI 正在思考中..." or similar, don't parse as markdown yet.
    // Markdown parsing will happen when actual AI response content is streamed.
    if (content.includes('AI 正在思考中...') || (content.startsWith('<strong>AI 思考过程:</strong>'))) {
        contentDiv.innerHTML = content; // Allow initial HTML for thinking message
    } else {
        contentDiv.innerHTML = marked.parse(content); // Parse other content as Markdown
    }

    messageDiv.appendChild(headerDiv);
    messageDiv.appendChild(contentDiv);
    return messageDiv;
}

// 添加消息到Agent对话界面 (现在使用辅助函数)
function addAgentMessage(role, content) {
    if (!agentChatMessages) return null;
    const messageElement = createAgentMessageElement(role, content);
    agentChatMessages.appendChild(messageElement);
    agentChatMessages.scrollTop = agentChatMessages.scrollHeight;
    return messageElement.id; // 返回创建的元素的ID，如果需要引用
}

// 移除指定的Agent消息 (这个函数可能不再需要，因为我们是更新现有消息或直接添加最终消息)
// function removeAgentMessage(messageId) {
//     if (messageId) {
//         const messageElement = document.getElementById(messageId);
//         if (messageElement) {
//             messageElement.remove();
//         }
//     }
// }

// === Agent功能代码结束 ===

// --- 自动滚动功能 ---
function setupAutoScrollForPreElement(preElement) {
    if (!preElement) return () => {}; 
    let userHasScrolledUp = false;

    preElement.addEventListener('scroll', () => {
        if (preElement.scrollTop + preElement.clientHeight < preElement.scrollHeight - 20) {
            userHasScrolledUp = true;
        } else {
            userHasScrolledUp = false;
        }
    });

    return function autoScrollIfEnabled() {
        if (!userHasScrolledUp) {
            preElement.scrollTop = preElement.scrollHeight;
        }
    };
}

// 为每个思考过程的 pre 元素设置自动滚动
const personnelThinkingAutoScroll = personnelThinkingPre ? setupAutoScrollForPreElement(personnelThinkingPre) : () => {};
const aiThinkingAutoScroll = aiThinkingPre ? setupAutoScrollForPreElement(aiThinkingPre) : () => {};
const seatModifyThinkingAutoScroll = seatModifyThinkingPre ? setupAutoScrollForPreElement(seatModifyThinkingPre) : () => {};
const agentThinkingAutoScroll = () => { // Modified to scroll the main chat messages if needed
    if (agentChatMessages) {
        // Check if the last message contains a pre tag (our thinking process)
        const lastMessage = agentChatMessages.lastElementChild;
        if (lastMessage) {
            const preInLastMessage = lastMessage.querySelector('pre');
            if (preInLastMessage) {
                // Scroll the pre element itself if it's scrollable
                if (preInLastMessage.scrollHeight > preInLastMessage.clientHeight) {
                     preInLastMessage.scrollTop = preInLastMessage.scrollHeight;
                }
            }
            // Always scroll the main chat container to the bottom to see the latest message/thinking
            agentChatMessages.scrollTop = agentChatMessages.scrollHeight;
        }
    }
};

    </script>
</body>
</html>
